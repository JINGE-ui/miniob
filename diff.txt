diff --git a/src/observer/handler/handler.h b/src/observer/handler/handler.h
index 1c73d3d..fd54a6a 100644
--- a/src/observer/handler/handler.h
+++ b/src/observer/handler/handler.h
@@ -43,7 +43,7 @@ typedef enum {
 } CompOp;
 
 //属性值类型
-typedef enum { chars, ints, floats, dates} AttrType;
+typedef enum { chars, ints, floats } AttrType;
 //属性值
 typedef struct _Value Value;
 struct _Value {
diff --git a/src/observer/sql/executor/execute_stage.cpp b/src/observer/sql/executor/execute_stage.cpp
index 657614a..151d3ec 100644
--- a/src/observer/sql/executor/execute_stage.cpp
+++ b/src/observer/sql/executor/execute_stage.cpp
@@ -36,10 +36,21 @@ See the Mulan PSL v2 for more details. */
 #include<algorithm>
 
 using namespace common;
-
-//by xiayuan：元数据校验，用于验证where子句的每一个条件是否有table来匹配，1表存在匹配，0表不存在并返回错误
+using namespace std;
+//by xiayuan：元数据校验，用于验证where子句的每一个条件的左右部分是否有table来匹配，1表存在匹配，0表不存在并返回错误
 std::vector<int>condition_match;
 
+std::vector<std::vector<string>> tables_value;
+std::vector<std::string> Cartesian_result, cur_table;
+std::unordered_map<std::string, int>relation_map_offset;
+std::vector<std::string>  relation_map_order;
+CompositeConditionFilter* condition_filter = new CompositeConditionFilter;
+int curtable_record_size = 0;
+
+
+//
+RC select_tables(Trx* trx, const char* db, const Selects& selects, TupleSet& tuple_set);
+
 RC create_selection_executor(Trx *trx, const Selects &selects, const char *db, const char *table_name, SelectExeNode &select_node);
 
 //! Constructor
@@ -217,6 +228,39 @@ void end_trx_if_need(Session *session, Trx *trx, bool all_right) {
     }
   }
 }
+//为了select-tables新增的函数
+void select_record_reader(const char* data, void* context) {
+    std::vector<string>* ptr_string = (std::vector<string>*)context;
+    string tmp(data, data + curtable_record_size);
+    (*ptr_string).push_back(tmp);
+}
+
+RC run(vector<vector<string>> &dimvalue, vector<string> &result, int layer, string curstring)
+{
+    if (layer < dimvalue.size() - 1)
+    {
+        if (dimvalue[layer].size() == 0) {
+            return RC::GENERIC_ERROR;
+        }
+        for (int i = 0; i < dimvalue[layer].size(); i++)
+        {
+            if (run(dimvalue, result, layer + 1, curstring + dimvalue[layer][i]) != RC::SUCCESS) {
+                return RC::GENERIC_ERROR;
+            }
+        }
+    }
+    else if (layer == dimvalue.size() - 1)
+    {
+        if (dimvalue[layer].size() == 0) {
+            return RC::GENERIC_ERROR;
+        }
+        for (int i = 0; i < dimvalue[layer].size(); i++)
+        {
+            result.push_back(curstring + dimvalue[layer][i]);
+        }
+    }
+    return RC::SUCCESS;
+}
 
 // 这里没有对输入的某些信息做合法性校验，比如查询的列名、where条件中的列名等，没有做必要的合法性校验
 // 需要补充上这一部分. 校验部分也可以放在resolve，不过跟execution放一起也没有关系
@@ -234,74 +278,65 @@ RC ExecuteStage::do_select(const char *db, Query *sql, SessionEvent *session_eve
       condition_match.push_back(0);
   }
 
-  // 把所有的表和只跟这张表关联的condition都拿出来，生成最底层的select 执行节点
-  std::vector<SelectExeNode *> select_nodes;
-  for (size_t i = 0; i < selects.relation_num; i++) {
-    const char *table_name = selects.relations[i];
-    SelectExeNode *select_node = new SelectExeNode;
-    rc = create_selection_executor(trx, selects, db, table_name, *select_node);
-    if (rc != RC::SUCCESS) {
-      delete select_node;
-      for (SelectExeNode *& tmp_node: select_nodes) {
-        delete tmp_node;
-      }
-      //元数据校验，添加错误打印信息
-      const char* response = "FAILURE\n";
-      session_event->set_response(response);
-      //
-      end_trx_if_need(session, trx, false);
-      return rc;
-    }
-    select_nodes.push_back(select_node);
-  }
+  TupleSet tuple_set; //查询结果保存
 
-  if (select_nodes.empty()) {
-    LOG_ERROR("No table given");
-    end_trx_if_need(session, trx, false);
-    return RC::SQL_SYNTAX;
-  }
+  relation_map_offset.clear();
+  relation_map_order.clear();
+  Cartesian_result.clear();
+  tables_value.clear();
+  cur_table.clear();
 
-  //by xiayuan：元数据校验，where子句中如果有条件未匹配，说明有非法列名
-  if ((find(condition_match.begin(), condition_match.end(), 0) != condition_match.end())
-      && !condition_match.empty()) {
-      for (SelectExeNode*& tmp_node : select_nodes) {
-          delete tmp_node;
+  if (selects.relation_num > 1) {   //多表查询
+      if (select_tables(trx, db, selects, tuple_set) != RC::SUCCESS) {
+          const char* response = "FAILURE\n";
+          session_event->set_response(response);
+          return RC::GENERIC_ERROR;
       }
-      //打印错误
-      const char* response = "FAILURE\n";
-      session_event->set_response(response);
+  } 
+  else if(selects.relation_num == 1) {  //单表查询
+        const char* table_name = selects.relations[0];
+        SelectExeNode* select_node = new SelectExeNode;
+        rc = create_selection_executor(trx, selects, db, table_name, *select_node);
+        if (rc != RC::SUCCESS) {
+            delete select_node;
+            //元数据校验，添加错误打印信息，错误有：select的非法列名，from的非法表名，where的非法列名
+            const char* response = "FAILURE\n";
+            session_event->set_response(response);
+            //
+            end_trx_if_need(session, trx, false);
+            return rc;
+        }
 
-      end_trx_if_need(session, trx, false);
+        //by xiayuan：元数据校验+support单表，where子句中如果有条件未匹配，说明有非法表名
+        if ((find(condition_match.begin(), condition_match.end(), 0) != condition_match.end())
+            && !condition_match.empty()) {
+            delete select_node;
+            //打印错误
+            const char* response = "FAILURE\n";
+            session_event->set_response(response);
 
-      return RC::GENERIC_ERROR;
+            end_trx_if_need(session, trx, false);
+            return RC::GENERIC_ERROR;
+        }
+        //
+        rc = select_node->execute(tuple_set);
+        if (rc != RC::SUCCESS) {
+            delete select_node;
+            end_trx_if_need(session, trx, false);
+            return rc;
+        }
+        delete select_node;
   }
-  
-
-  std::vector<TupleSet> tuple_sets;
-  for (SelectExeNode *&node: select_nodes) {
-    TupleSet tuple_set;
-    rc = node->execute(tuple_set);
-    if (rc != RC::SUCCESS) {
-      for (SelectExeNode *& tmp_node: select_nodes) {
-        delete tmp_node;
-      }
+  else {  //relation_num<1
+      LOG_ERROR("No table given");
       end_trx_if_need(session, trx, false);
-      return rc;
-    } else {
-      tuple_sets.push_back(std::move(tuple_set));
-    }
+      return RC::SQL_SYNTAX;
   }
+  
+
   std::stringstream ss;
-  if (tuple_sets.size() > 1) {
-    // 本次查询了多张表，需要做join操作
-  } else {
-    // 当前只查询一张表，直接返回结果即可
-    tuple_sets.front().print(ss);
-  }
+  tuple_set.print(ss, selects.relation_num);
 
-  for (SelectExeNode *& tmp_node: select_nodes) {
-    delete tmp_node;
-  }
   session_event->set_response(ss.str());
   end_trx_if_need(session, trx, true);
   return rc;
@@ -315,6 +350,17 @@ bool match_table(const Selects &selects, const char *table_name_in_condition, co
   return selects.relation_num == 1;
 }
 
+//为了支持多表查询，对match_table重载
+bool match_table(const Selects& selects, const char* table_name_in_condition) {
+    if (table_name_in_condition == nullptr || selects.relation_num == 1) {   //不满足多表查询的匹配规则 
+        return false;
+    }
+    if (relation_map_offset.find(table_name_in_condition) == relation_map_offset.end()) {   //该表不存在
+        return false;
+    }
+    return true;
+}
+
 static RC schema_add_field(Table *table, const char *field_name, TupleSchema &schema) {
   const FieldMeta *field_meta = table->table_meta().field(field_name);
   if (nullptr == field_meta) {
@@ -332,8 +378,6 @@ RC create_selection_executor(Trx *trx, const Selects &selects, const char *db, c
   TupleSchema schema;
   Table * table = DefaultHandler::get_default().find_table(db, table_name);
 
-  std::stringstream ss;
-  ss << "start create executor" << std::endl;
   if (nullptr == table) {
     LOG_WARN("No such table [%s] in db [%s]", table_name, db);
     return RC::SCHEMA_TABLE_NOT_EXIST;
@@ -355,6 +399,9 @@ RC create_selection_executor(Trx *trx, const Selects &selects, const char *db, c
         }
       }
     }
+    else {   //非法表名
+        return RC::GENERIC_ERROR;
+    }
   }
 
   // 找出仅与此表相关的过滤条件, 或者都是值的过滤条件
@@ -385,3 +432,148 @@ RC create_selection_executor(Trx *trx, const Selects &selects, const char *db, c
 
   return select_node.init(trx, table, std::move(schema), std::move(condition_filters));
 }
+
+
+RC select_tables(Trx* trx, const char* db, const Selects& selects, TupleSet& tuple_set) {
+    //多表查询，获得每个表的全部内容
+    int none_flag = 0;
+    for (int i = selects.relation_num - 1, offset = 0; i >= 0; i--)
+    {
+        const char* table_name = selects.relations[i];
+        relation_map_order.push_back(table_name);
+
+        Table* table = DefaultHandler::get_default().find_table(db, table_name);
+        if (nullptr == table) {
+            LOG_WARN("No such table [%s] in db [%s]", table_name, db);
+            return RC::SCHEMA_TABLE_NOT_EXIST;
+        }
+        const TableMeta tablemeta = table->table_meta();
+
+        relation_map_offset[table_name] = offset;
+        curtable_record_size = tablemeta.record_size();   //全局变量，当前表的一条记录的长度
+        offset += tablemeta.record_size();  //累加offset
+
+        cur_table.clear();   //当前表的所有记录存在cur_table
+        table->scan_record(trx, nullptr, -1, (void*)(&cur_table), select_record_reader);
+        if (cur_table.empty()) {  //如果存在一个表为空,多表查询的结果一定为空，所以只需获取tupleschema，即可结束
+            none_flag = 1;
+        }
+        tables_value.push_back(cur_table);  //tables_value存放所有表的记录
+        cur_table.clear();
+    }
+    LOG_INFO("get table values\n");
+
+    //获取要投影的字段
+    TupleSchema schema;
+    for (int i = selects.attr_num - 1; i >= 0; i--) {
+        const RelAttr& attr = selects.attributes[i];
+        if (attr.relation_name == nullptr) {  //没有表名.修饰
+            if (strcmp("*", attr.attribute_name) != 0) {   //多表查询 不是*，必须有表名.修饰
+                return RC::GENERIC_ERROR;
+            }
+            //*：投影全部字段
+            schema.clear();
+            for (vector<string>::iterator it = relation_map_order.begin(); it < relation_map_order.end(); it++) {
+                Table* table = DefaultHandler::get_default().find_table(db, (*it).c_str());
+                TupleSchema::from_table(table, schema);
+            }
+            break;
+        }
+        else {  //有表名.修饰
+            if (match_table(selects, attr.relation_name) == false) {  //非法表名
+                return RC::GENERIC_ERROR;
+            }
+            Table* table = DefaultHandler::get_default().find_table(db, attr.relation_name);
+            RC rc = schema_add_field(table, attr.attribute_name, schema);
+            if (rc != RC::SUCCESS) {
+                return rc;
+            }
+        }
+    }
+    LOG_INFO("get tupleschema\n");
+
+    if (none_flag) {
+        tuple_set.clear();
+        tuple_set.set_schema(schema);
+        LOG_INFO("exit in advance\n");
+        return RC::SUCCESS;
+    }
+
+    //获取笛卡尔积
+    if (run(tables_value, Cartesian_result, 0, "") != RC::SUCCESS) {   //获取的笛卡尔积存在Cartesian_result，run函数按理不会执行失败
+        LOG_INFO("Failed to excute run() function!\n");
+        return RC::GENERIC_ERROR;
+    }
+    LOG_INFO("get Cartesian_result\n");
+    //生成过滤列表
+    std::vector<DefaultConditionFilter*> condition_filters;
+    for (size_t i = 0; i < selects.condition_num; i++) {
+        const Condition& condition = selects.conditions[i];
+        if ((condition.left_is_attr == 0 && condition.right_is_attr == 0) || // 两边都是值
+            (condition.left_is_attr == 1 && condition.right_is_attr == 0 && match_table(selects, condition.left_attr.relation_name)) ||  // 左边是属性右边是值
+            (condition.left_is_attr == 0 && condition.right_is_attr == 1 && match_table(selects, condition.right_attr.relation_name)) ||  // 左边是值，右边是属性名
+            (condition.left_is_attr == 1 && condition.right_is_attr == 1 &&
+                match_table(selects, condition.left_attr.relation_name) && match_table(selects, condition.right_attr.relation_name)) // 左右都是属性名，并且表名都符合
+            ) {
+            //获取左右表在笛卡尔积中的偏移
+            int left_offset = 0, right_offset = 0;
+            Table* left_table=nullptr, * right_table=nullptr;
+            if (condition.left_is_attr == 1 && match_table(selects, condition.left_attr.relation_name)) {   //左边是带表名.的属性
+                left_offset = relation_map_offset[condition.left_attr.relation_name];   //应该不会出现key不存在的现象
+                left_table = DefaultHandler::get_default().find_table(db, condition.left_attr.relation_name);
+            }
+            if (condition.right_is_attr == 1 && match_table(selects, condition.right_attr.relation_name)) {
+                right_offset = relation_map_offset[condition.right_attr.relation_name];
+                right_table = DefaultHandler::get_default().find_table(db, condition.right_attr.relation_name);
+            }
+            /*
+            if (left_table == nullptr || right_table == nullptr) {
+                LOG_ERROR("an unexcepted error!\n");
+                return RC::GENERIC_ERROR;
+            }
+            */
+
+            DefaultConditionFilter* condition_filter = new DefaultConditionFilter();
+            RC rc = condition_filter->init(left_table, right_table, condition, left_offset, right_offset);
+            if (rc != RC::SUCCESS) {   //非法列名
+                delete condition_filter;
+                for (DefaultConditionFilter*& filter : condition_filters) {
+                    delete filter;
+                }
+                return rc;
+            }
+            condition_filters.push_back(condition_filter);
+        }
+        else {   //有非法表名
+            return RC::GENERIC_ERROR;
+        }
+    }
+    condition_filter->init((const ConditionFilter**)condition_filters.data(), condition_filters.size());
+    LOG_INFO("get condition filters\n");
+    //开始过滤
+    vector<string>::iterator it = Cartesian_result.begin();
+    while (it != Cartesian_result.end()) {
+        Record rec; 
+        rec.data = (char*)((*it).c_str());
+        if (condition_filter->filter(rec)) {   //false
+            it++;
+        }else{
+            it = Cartesian_result.erase(it);
+        }
+    }
+
+    for (DefaultConditionFilter*& filter : condition_filters) {
+        delete filter;
+    }
+    LOG_INFO("success to filter:\n");
+
+    //投影
+    tuple_set.clear();
+    tuple_set.set_schema(schema);
+    TupleRecordConverter converter(nullptr, tuple_set);
+
+    for (string record : Cartesian_result) {
+        converter.add_record(record.c_str(), db, relation_map_offset);
+    }
+    return RC::SUCCESS;
+}
diff --git a/src/observer/sql/executor/tuple.cpp b/src/observer/sql/executor/tuple.cpp
index 9566316..6562c44 100644
--- a/src/observer/sql/executor/tuple.cpp
+++ b/src/observer/sql/executor/tuple.cpp
@@ -16,6 +16,8 @@ See the Mulan PSL v2 for more details. */
 #include "storage/common/table.h"
 #include "common/log/log.h"
 
+#include "storage/default/default_handler.h"
+
 Tuple::Tuple(const Tuple &other) {
   LOG_PANIC("Copy constructor of tuple is not supported");
   exit(1);
@@ -51,6 +53,7 @@ void Tuple::add(int value) {
 void Tuple::add(float value) {
   add(new FloatValue(value));
 }
+
 void Tuple::addDate(int value){
   add(new DateValue(value));
 }
@@ -111,6 +114,26 @@ int TupleSchema::index_of_field(const char *table_name, const char *field_name)
   return -1;
 }
 
+void TupleSchema::print(std::ostream& os, int table_num) const {
+    if (fields_.empty()) {
+        os << "No schema";
+        return;
+    }
+
+    for (std::vector<TupleField>::const_iterator iter = fields_.begin(), end = --fields_.end();
+        iter != end; ++iter) {
+        if (table_num > 1) {
+            os << iter->table_name() << ".";
+        }
+        os << iter->field_name() << " | ";
+    }
+
+    if (table_num > 1) {
+        os << fields_.back().table_name() << ".";
+    }
+    os << fields_.back().field_name() << std::endl;
+}
+
 void TupleSchema::print(std::ostream &os) const {
   if (fields_.empty()) {
     os << "No schema";
@@ -165,6 +188,26 @@ void TupleSet::clear() {
   schema_.clear();
 }
 
+void TupleSet::print(std::ostream& os, int table_num) const {
+    if (schema_.fields().empty()) {
+        LOG_WARN("Got empty schema");
+        return;
+    }
+
+    schema_.print(os, table_num);
+
+    for (const Tuple& item : tuples_) {
+        const std::vector<std::shared_ptr<TupleValue>>& values = item.values();
+        for (std::vector<std::shared_ptr<TupleValue>>::const_iterator iter = values.begin(), end = --values.end();
+            iter != end; ++iter) {
+            (*iter)->to_string(os);
+            os << " | ";
+        }
+        values.back()->to_string(os);
+        os << std::endl;
+    }
+}
+
 void TupleSet::print(std::ostream &os) const {
   if (schema_.fields().empty()) {
     LOG_WARN("Got empty schema");
@@ -172,11 +215,11 @@ void TupleSet::print(std::ostream &os) const {
   }
 
   schema_.print(os);
+
   for (const Tuple &item : tuples_) {
     const std::vector<std::shared_ptr<TupleValue>> &values = item.values();
     for (std::vector<std::shared_ptr<TupleValue>>::const_iterator iter = values.begin(), end = --values.end();
           iter != end; ++iter) {
-      LOG_INFO("print it\n");
       (*iter)->to_string(os);
       os << " | ";
     }
@@ -213,7 +256,61 @@ const std::vector<Tuple> &TupleSet::tuples() const {
 TupleRecordConverter::TupleRecordConverter(Table *table, TupleSet &tuple_set) :
       table_(table), tuple_set_(tuple_set){
 }
+void TupleRecordConverter::add_record(const char* record, const char* db, const unordered_map<string, int> &table_map_offset) {
+    //table_ = nullptr
+    const TupleSchema& schema = tuple_set_.schema();
+    Tuple tuple;
+    for (const TupleField& field : schema.fields()) {
+        //get table offest: table_offset
+        const char* table_name = field.table_name();
+        int table_offset = 0;
+        Table* table = DefaultHandler::get_default().find_table(db, table_name);
+        if (nullptr == table) {   //应该不会发生
+            LOG_WARN("unexpected error!\n");
+            return;
+            //return RC::SCHEMA_TABLE_NOT_EXIST;
+        }
+        if (table_map_offset.find(table_name) == table_map_offset.end()) {   //理论上不会发生
+            LOG_WARN("unexpected error!\n");
+            return;
+            //return RC::GENERIC_ERROR;
+        }
+        table_offset = table_map_offset.at(table_name);
+        //get field offset: field_meta->offset()
+        const TableMeta& table_meta = table->table_meta();
+        const FieldMeta* field_meta = table_meta.field(field.field_name());
+
+        assert(field_meta != nullptr);
+        //
+        switch (field_meta->type()) {
+        case INTS: {
+            int value = *(int*)(record + field_meta->offset() + table_offset);    //add table offset
+            tuple.add(value);
+        }
+                 break;
+        case FLOATS: {
+            float value = *(float*)(record + field_meta->offset() + table_offset);    //add table offset
+            tuple.add(value);
+        }
+                   break;
+        case CHARS: {
+            const char* s = record + field_meta->offset() + table_offset;  // 现在当做Cstring来处理
+            tuple.add(s, strlen(s));
+        }
+                  break;
+        case DATES:{
+-            int value = *(int*)(record + field_meta->offset());
+-            tuple.addDate(value);
+-       }
+-                 break;
+        default: {
+            LOG_PANIC("Unsupported field type. type=%d", field_meta->type());
+        }
+        }
+    }
 
+    tuple_set_.add(std::move(tuple));
+}
 void TupleRecordConverter::add_record(const char *record) {
   const TupleSchema &schema = tuple_set_.schema();
   Tuple tuple;
@@ -231,17 +328,12 @@ void TupleRecordConverter::add_record(const char *record) {
         float value = *(float *)(record + field_meta->offset());
         tuple.add(value);
       }
-      break;
+        break;
       case CHARS: {
         const char *s = record + field_meta->offset();  // 现在当做Cstring来处理
         tuple.add(s, strlen(s));
       }
       break;
-      case DATES:{
-        int value = *(int*)(record + field_meta->offset());
-        tuple.addDate(value);
-      }
-      break;
       default: {
         LOG_PANIC("Unsupported field type. type=%d", field_meta->type());
       }
diff --git a/src/observer/sql/executor/tuple.h b/src/observer/sql/executor/tuple.h
index 4e8b7f2..f94bead 100644
--- a/src/observer/sql/executor/tuple.h
+++ b/src/observer/sql/executor/tuple.h
@@ -17,10 +17,13 @@ See the Mulan PSL v2 for more details. */
 
 #include <memory>
 #include <vector>
-#include "common/log/log.h"
+
 #include "sql/parser/parse.h"
 #include "sql/executor/value.h"
 
+#include <unordered_map>
+using namespace std;
+
 class Table;
 
 class Tuple {
@@ -40,7 +43,6 @@ public:
   void add(float value);
   void add(const char *s, int len);
   void addDate(int value);
-
   const std::vector<std::shared_ptr<TupleValue>> &values() const {
     return values_;
   }
@@ -109,6 +111,10 @@ public:
   }
 
   void print(std::ostream &os) const;
+
+  //for select tables�����Ӳ���table_num
+  void print(std::ostream& os, int table_num) const;
+
 public:
   static void from_table(const Table *table, TupleSchema &schema);
 private:
@@ -139,6 +145,9 @@ public:
   const std::vector<Tuple> &tuples() const;
 
   void print(std::ostream &os) const;
+  //for select tables�����Ӳ���table_num
+  void print(std::ostream& os, int table_num) const;
+
 public:
   const TupleSchema &schema() const {
     return schema_;
@@ -153,6 +162,12 @@ public:
   TupleRecordConverter(Table *table, TupleSet &tuple_set);
 
   void add_record(const char *record);
+
+  /*
+  for: select tables
+  ����table_map_offset������table�����ڶ�����ѿ�������ļ�¼record�е�ƫ������
+  */
+  void add_record(const char* record, const char* db, const unordered_map<string, int> &table_map_offset);
 private:
   Table *table_;
   TupleSet &tuple_set_;
diff --git a/src/observer/sql/executor/value.h b/src/observer/sql/executor/value.h
index 6a7e124..e3c54f3 100644
--- a/src/observer/sql/executor/value.h
+++ b/src/observer/sql/executor/value.h
@@ -15,8 +15,8 @@ See the Mulan PSL v2 for more details. */
 #ifndef __OBSERVER_SQL_EXECUTOR_VALUE_H_
 #define __OBSERVER_SQL_EXECUTOR_VALUE_H_
 
-#include "common/log/log.h"
 #include <string.h>
+
 #include <string>
 #include <ostream>
 
@@ -91,38 +91,5 @@ private:
   std::string value_;
 };
 
-class DateValue : public TupleValue {
-public:
-  explicit DateValue(int value) : value_(value) {
-  }
-
-  void to_string(std::ostream &os) const override {
-    std::string datestr;
-    int year = value_/10000;
-    int month = value_/100-year*100;
-    int datetime = value_-10000*year-100*month;
-    bool madd0 = month > 9 ? 0:1;
-    bool dadd0 = datetime > 9 ? 0:1;
-    if(madd0)
-      datestr = std::to_string(year) + "-0" + std::to_string(month);
-    else 
-      datestr = std::to_string(year) + "-" + std::to_string(month);
-    if(dadd0)
-      datestr += "-0" + std::to_string(datetime);
-    else
-      datestr += "-" + std::to_string(datetime);
-    os << datestr;
-  }
-
-  int compare(const TupleValue &other) const override {
-    const DateValue & int_other = (const DateValue &)other;
-    return value_ - int_other.value_;
-  }
-
-private:
-  int value_;
-
-};
-
 
 #endif //__OBSERVER_SQL_EXECUTOR_VALUE_H_
diff --git a/src/observer/sql/parser/lex.yy.c b/src/observer/sql/parser/lex.yy.c
index 115133f..fad4028 100644
--- a/src/observer/sql/parser/lex.yy.c
+++ b/src/observer/sql/parser/lex.yy.c
@@ -7,24 +7,12 @@
 
 #define FLEX_SCANNER
 #define YY_FLEX_MAJOR_VERSION 2
-#define YY_FLEX_MINOR_VERSION 6
-#define YY_FLEX_SUBMINOR_VERSION 4
+#define YY_FLEX_MINOR_VERSION 5
+#define YY_FLEX_SUBMINOR_VERSION 35
 #if YY_FLEX_SUBMINOR_VERSION > 0
 #define FLEX_BETA
 #endif
 
-#ifdef yyget_lval
-#define yyget_lval_ALREADY_DEFINED
-#else
-#define yyget_lval yyget_lval
-#endif
-
-#ifdef yyset_lval
-#define yyset_lval_ALREADY_DEFINED
-#else
-#define yyset_lval yyset_lval
-#endif
-
 /* First, we deal with  platform-specific or compiler-specific issues. */
 
 /* begin standard C headers. */
@@ -58,6 +46,7 @@ typedef int16_t flex_int16_t;
 typedef uint16_t flex_uint16_t;
 typedef int32_t flex_int32_t;
 typedef uint32_t flex_uint32_t;
+typedef uint64_t flex_uint64_t;
 #else
 typedef signed char flex_int8_t;
 typedef short int flex_int16_t;
@@ -65,6 +54,7 @@ typedef int flex_int32_t;
 typedef unsigned char flex_uint8_t; 
 typedef unsigned short int flex_uint16_t;
 typedef unsigned int flex_uint32_t;
+#endif /* ! C99 */
 
 /* Limits of integral types. */
 #ifndef INT8_MIN
@@ -95,32 +85,38 @@ typedef unsigned int flex_uint32_t;
 #define UINT32_MAX             (4294967295U)
 #endif
 
-#ifndef SIZE_MAX
-#define SIZE_MAX               (~(size_t)0)
-#endif
+#endif /* ! FLEXINT_H */
 
-#endif /* ! C99 */
+#ifdef __cplusplus
 
-#endif /* ! FLEXINT_H */
+/* The "const" storage-class-modifier is valid. */
+#define YY_USE_CONST
 
-/* begin standard C++ headers. */
+#else	/* ! __cplusplus */
 
-/* TODO: this is always defined, so inline it */
-#define yyconst const
+/* C99 requires __STDC__ to be defined as 1. */
+#if defined (__STDC__)
+
+#define YY_USE_CONST
 
-#if defined(__GNUC__) && __GNUC__ >= 3
-#define yynoreturn __attribute__((__noreturn__))
+#endif	/* defined (__STDC__) */
+#endif	/* ! __cplusplus */
+
+#ifdef YY_USE_CONST
+#define yyconst const
 #else
-#define yynoreturn
+#define yyconst
 #endif
 
 /* Returned upon end-of-file. */
 #define YY_NULL 0
 
-/* Promotes a possibly negative, possibly signed char to an
- *   integer in range [0..255] for use as an array index.
+/* Promotes a possibly negative, possibly signed char to an unsigned
+ * integer for use as an array index.  If the signed char is negative,
+ * we want to instead treat it as an 8-bit unsigned char, hence the
+ * double cast.
  */
-#define YY_SC_TO_UI(c) ((YY_CHAR) (c))
+#define YY_SC_TO_UI(c) ((unsigned int) (unsigned char) c)
 
 /* An opaque pointer. */
 #ifndef YY_TYPEDEF_YY_SCANNER_T
@@ -144,29 +140,25 @@ typedef void* yyscan_t;
  * definition of BEGIN.
  */
 #define BEGIN yyg->yy_start = 1 + 2 *
+
 /* Translate the current start state into a value that can be later handed
  * to BEGIN to return to the state.  The YYSTATE alias is for lex
  * compatibility.
  */
 #define YY_START ((yyg->yy_start - 1) / 2)
 #define YYSTATE YY_START
+
 /* Action number for EOF rule of a given start state. */
 #define YY_STATE_EOF(state) (YY_END_OF_BUFFER + state + 1)
+
 /* Special action meaning "start processing a new file". */
-#define YY_NEW_FILE yyrestart( yyin , yyscanner )
+#define YY_NEW_FILE yyrestart(yyin ,yyscanner )
+
 #define YY_END_OF_BUFFER_CHAR 0
 
 /* Size of default input buffer. */
 #ifndef YY_BUF_SIZE
-#ifdef __ia64__
-/* On IA-64, the buffer size is 16k, not 8k.
- * Moreover, YY_BUF_SIZE is 2*YY_READ_BUF_SIZE in the general case.
- * Ditto for the __ia64__ case accordingly.
- */
-#define YY_BUF_SIZE 32768
-#else
 #define YY_BUF_SIZE 16384
-#endif /* __ia64__ */
 #endif
 
 /* The state buf must be large enough to hold one state per character in the main buffer.
@@ -186,9 +178,8 @@ typedef size_t yy_size_t;
 #define EOB_ACT_CONTINUE_SCAN 0
 #define EOB_ACT_END_OF_FILE 1
 #define EOB_ACT_LAST_MATCH 2
-    
+
     #define YY_LESS_LINENO(n)
-    #define YY_LINENO_REWIND_TO(ptr)
     
 /* Return all but the first "n" matched characters back to the input stream. */
 #define yyless(n) \
@@ -203,6 +194,7 @@ typedef size_t yy_size_t;
 		YY_DO_BEFORE_ACTION; /* set up yytext again */ \
 		} \
 	while ( 0 )
+
 #define unput(c) yyunput( c, yyg->yytext_ptr , yyscanner )
 
 #ifndef YY_STRUCT_YY_BUFFER_STATE
@@ -217,12 +209,12 @@ struct yy_buffer_state
 	/* Size of input buffer in bytes, not including room for EOB
 	 * characters.
 	 */
-	int yy_buf_size;
+	yy_size_t yy_buf_size;
 
 	/* Number of characters read into yy_ch_buf, not including EOB
 	 * characters.
 	 */
-	int yy_n_chars;
+	yy_size_t yy_n_chars;
 
 	/* Whether we "own" the buffer - i.e., we know we created it,
 	 * and can realloc() it to grow it, and should free() it to
@@ -245,7 +237,7 @@ struct yy_buffer_state
 
     int yy_bs_lineno; /**< The line count. */
     int yy_bs_column; /**< The column count. */
-
+    
 	/* Whether to try to fill the input buffer when we reach the
 	 * end of it.
 	 */
@@ -279,79 +271,86 @@ struct yy_buffer_state
 #define YY_CURRENT_BUFFER ( yyg->yy_buffer_stack \
                           ? yyg->yy_buffer_stack[yyg->yy_buffer_stack_top] \
                           : NULL)
+
 /* Same as previous macro, but useful when we know that the buffer stack is not
  * NULL or when we need an lvalue. For internal use only.
  */
 #define YY_CURRENT_BUFFER_LVALUE yyg->yy_buffer_stack[yyg->yy_buffer_stack_top]
 
-void yyrestart ( FILE *input_file , yyscan_t yyscanner );
-void yy_switch_to_buffer ( YY_BUFFER_STATE new_buffer , yyscan_t yyscanner );
-YY_BUFFER_STATE yy_create_buffer ( FILE *file, int size , yyscan_t yyscanner );
-void yy_delete_buffer ( YY_BUFFER_STATE b , yyscan_t yyscanner );
-void yy_flush_buffer ( YY_BUFFER_STATE b , yyscan_t yyscanner );
-void yypush_buffer_state ( YY_BUFFER_STATE new_buffer , yyscan_t yyscanner );
-void yypop_buffer_state ( yyscan_t yyscanner );
+void yyrestart (FILE *input_file ,yyscan_t yyscanner );
+void yy_switch_to_buffer (YY_BUFFER_STATE new_buffer ,yyscan_t yyscanner );
+YY_BUFFER_STATE yy_create_buffer (FILE *file,int size ,yyscan_t yyscanner );
+void yy_delete_buffer (YY_BUFFER_STATE b ,yyscan_t yyscanner );
+void yy_flush_buffer (YY_BUFFER_STATE b ,yyscan_t yyscanner );
+void yypush_buffer_state (YY_BUFFER_STATE new_buffer ,yyscan_t yyscanner );
+void yypop_buffer_state (yyscan_t yyscanner );
 
-static void yyensure_buffer_stack ( yyscan_t yyscanner );
-static void yy_load_buffer_state ( yyscan_t yyscanner );
-static void yy_init_buffer ( YY_BUFFER_STATE b, FILE *file , yyscan_t yyscanner );
-#define YY_FLUSH_BUFFER yy_flush_buffer( YY_CURRENT_BUFFER , yyscanner)
+static void yyensure_buffer_stack (yyscan_t yyscanner );
+static void yy_load_buffer_state (yyscan_t yyscanner );
+static void yy_init_buffer (YY_BUFFER_STATE b,FILE *file ,yyscan_t yyscanner );
 
-YY_BUFFER_STATE yy_scan_buffer ( char *base, yy_size_t size , yyscan_t yyscanner );
-YY_BUFFER_STATE yy_scan_string ( const char *yy_str , yyscan_t yyscanner );
-YY_BUFFER_STATE yy_scan_bytes ( const char *bytes, int len , yyscan_t yyscanner );
+#define YY_FLUSH_BUFFER yy_flush_buffer(YY_CURRENT_BUFFER ,yyscanner)
 
-void *yyalloc ( yy_size_t , yyscan_t yyscanner );
-void *yyrealloc ( void *, yy_size_t , yyscan_t yyscanner );
-void yyfree ( void * , yyscan_t yyscanner );
+YY_BUFFER_STATE yy_scan_buffer (char *base,yy_size_t size ,yyscan_t yyscanner );
+YY_BUFFER_STATE yy_scan_string (yyconst char *yy_str ,yyscan_t yyscanner );
+YY_BUFFER_STATE yy_scan_bytes (yyconst char *bytes,yy_size_t len ,yyscan_t yyscanner );
+
+void *yyalloc (yy_size_t ,yyscan_t yyscanner );
+void *yyrealloc (void *,yy_size_t ,yyscan_t yyscanner );
+void yyfree (void * ,yyscan_t yyscanner );
 
 #define yy_new_buffer yy_create_buffer
+
 #define yy_set_interactive(is_interactive) \
 	{ \
 	if ( ! YY_CURRENT_BUFFER ){ \
         yyensure_buffer_stack (yyscanner); \
 		YY_CURRENT_BUFFER_LVALUE =    \
-            yy_create_buffer( yyin, YY_BUF_SIZE , yyscanner); \
+            yy_create_buffer(yyin,YY_BUF_SIZE ,yyscanner); \
 	} \
 	YY_CURRENT_BUFFER_LVALUE->yy_is_interactive = is_interactive; \
 	}
+
 #define yy_set_bol(at_bol) \
 	{ \
 	if ( ! YY_CURRENT_BUFFER ){\
         yyensure_buffer_stack (yyscanner); \
 		YY_CURRENT_BUFFER_LVALUE =    \
-            yy_create_buffer( yyin, YY_BUF_SIZE , yyscanner); \
+            yy_create_buffer(yyin,YY_BUF_SIZE ,yyscanner); \
 	} \
 	YY_CURRENT_BUFFER_LVALUE->yy_at_bol = at_bol; \
 	}
+
 #define YY_AT_BOL() (YY_CURRENT_BUFFER_LVALUE->yy_at_bol)
 
 /* Begin user sect3 */
 
-#define yywrap(yyscanner) (/*CONSTCOND*/1)
+#define yywrap(n) 1
 #define YY_SKIP_YYWRAP
-typedef flex_uint8_t YY_CHAR;
+
+typedef unsigned char YY_CHAR;
 
 typedef int yy_state_type;
 
 #define yytext_ptr yytext_r
 
-static yy_state_type yy_get_previous_state ( yyscan_t yyscanner );
-static yy_state_type yy_try_NUL_trans ( yy_state_type current_state  , yyscan_t yyscanner);
-static int yy_get_next_buffer ( yyscan_t yyscanner );
-static void yynoreturn yy_fatal_error ( const char* msg , yyscan_t yyscanner );
+static yy_state_type yy_get_previous_state (yyscan_t yyscanner );
+static yy_state_type yy_try_NUL_trans (yy_state_type current_state  ,yyscan_t yyscanner);
+static int yy_get_next_buffer (yyscan_t yyscanner );
+static void yy_fatal_error (yyconst char msg[] ,yyscan_t yyscanner );
 
 /* Done after the current pattern has been matched and before the
  * corresponding action - sets up yytext.
  */
 #define YY_DO_BEFORE_ACTION \
 	yyg->yytext_ptr = yy_bp; \
-	yyleng = (int) (yy_cp - yy_bp); \
+	yyleng = (yy_size_t) (yy_cp - yy_bp); \
 	yyg->yy_hold_char = *yy_cp; \
 	*yy_cp = '\0'; \
 	yyg->yy_c_buf_p = yy_cp;
-#define YY_NUM_RULES 52
-#define YY_END_OF_BUFFER 53
+
+#define YY_NUM_RULES 50
+#define YY_END_OF_BUFFER 51
 /* This struct is not used in this scanner,
    but its presence is necessary. */
 struct yy_trans_info
@@ -359,44 +358,42 @@ struct yy_trans_info
 	flex_int32_t yy_verify;
 	flex_int32_t yy_nxt;
 	};
-static const flex_int16_t yy_accept[163] =
+static yyconst flex_int16_t yy_accept[151] =
     {   0,
-        0,    0,    0,    0,   53,   51,    1,    2,   51,   41,
-       42,    8,   43,   51,    7,    3,    6,   47,   44,   49,
-       40,   40,   40,   40,   40,   40,   40,   40,   40,   40,
-       40,   40,   40,   40,   40,   40,   40,   52,    0,   50,
-        0,    3,    0,   45,   46,   48,   40,   40,   40,   40,
-       40,   40,   40,   40,   40,   40,   40,   40,   40,   40,
-       40,   40,   17,   40,   40,   40,   40,   40,   40,   40,
-       40,    0,    4,   23,   40,   40,   40,   40,   40,   40,
-       40,   40,   40,   40,   40,   40,   40,   40,   40,   33,
-       40,   40,   40,   29,   40,   40,   40,   40,   40,   40,
-
-        0,   40,   34,   40,   40,   38,   36,   40,   11,   13,
-        9,   40,   21,   10,   40,   40,   40,   25,   37,   40,
-       40,   18,   19,   40,   40,   40,   40,    0,   30,   40,
-       40,   40,   35,   16,   40,   40,   40,   40,   14,   40,
-       40,   22,    0,   31,   12,   27,   39,   24,   40,   20,
-       15,   28,   26,    0,   40,    0,    0,   32,    0,    5,
-        0,    0
+        0,    0,    0,    0,   51,   49,    1,    2,   49,   39,
+       40,    7,   41,   49,    6,    3,    5,   45,   42,   47,
+       38,   38,   38,   38,   38,   38,   38,   38,   38,   38,
+       38,   38,   38,   38,   38,   38,   38,   50,    0,   48,
+        3,    0,   43,   44,   46,   38,   38,   38,   38,   38,
+       38,   38,   38,   38,   38,   38,   38,   38,   38,   38,
+       38,   16,   38,   38,   38,   38,   38,   38,   38,   38,
+        4,   22,   38,   38,   38,   38,   38,   38,   38,   38,
+       38,   38,   38,   38,   38,   38,   38,   32,   38,   38,
+       38,   28,   38,   38,   38,   38,   38,   38,   38,   33,
+
+       38,   38,   36,   38,   10,   12,    8,   38,   20,    9,
+       38,   38,   38,   24,   35,   38,   38,   17,   18,   38,
+       38,   38,   38,   29,   38,   38,   38,   34,   15,   38,
+       38,   38,   38,   13,   38,   38,   21,   30,   11,   26,
+       37,   23,   38,   19,   14,   27,   25,   38,   31,    0
     } ;
 
-static const YY_CHAR yy_ec[256] =
+static yyconst flex_int32_t yy_ec[256] =
     {   0,
         1,    1,    1,    1,    1,    1,    1,    2,    2,    3,
         1,    2,    1,    1,    1,    1,    1,    1,    1,    1,
         1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
         1,    4,    1,    5,    1,    1,    1,    1,    5,    6,
-        7,    8,    1,    9,   10,   11,   12,   13,   14,   14,
-       14,   14,   14,   14,   14,   14,   14,    1,   15,   16,
-       17,   18,    1,    1,   19,   20,   21,   22,   23,   24,
-       25,   26,   27,   28,   29,   30,   31,   32,   33,   34,
-       28,   35,   36,   37,   38,   39,   40,   41,   42,   28,
-        1,    1,    1,    1,   28,    1,   19,   20,   21,   22,
-
-       23,   24,   25,   26,   27,   28,   29,   30,   31,   32,
-       33,   34,   28,   35,   36,   37,   38,   39,   40,   41,
-       42,   28,    1,    1,    1,    1,    1,    1,    1,    1,
+        7,    8,    1,    9,   10,   11,   12,   13,   13,   13,
+       13,   13,   13,   13,   13,   13,   13,    1,   14,   15,
+       16,   17,    1,    1,   18,   19,   20,   21,   22,   23,
+       24,   25,   26,   27,   28,   29,   30,   31,   32,   33,
+       27,   34,   35,   36,   37,   38,   39,   40,   41,   27,
+        1,    1,    1,    1,   27,    1,   18,   19,   20,   21,
+
+       22,   23,   24,   25,   26,   27,   28,   29,   30,   31,
+       32,   33,   27,   34,   35,   36,   37,   38,   39,   40,
+       41,   27,    1,    1,    1,    1,    1,    1,    1,    1,
         1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
         1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
         1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
@@ -413,181 +410,135 @@ static const YY_CHAR yy_ec[256] =
         1,    1,    1,    1,    1
     } ;
 
-static const YY_CHAR yy_meta[43] =
+static yyconst flex_int32_t yy_meta[42] =
     {   0,
         1,    1,    1,    2,    2,    1,    1,    1,    1,    2,
-        2,    2,    3,    3,    1,    1,    1,    1,    3,    3,
+        2,    2,    3,    1,    1,    1,    1,    3,    3,    3,
         3,    3,    3,    3,    3,    3,    3,    3,    3,    3,
         3,    3,    3,    3,    3,    3,    3,    3,    3,    3,
-        3,    3
+        3
     } ;
 
-static const flex_int16_t yy_base[167] =
+static yyconst flex_int16_t yy_base[155] =
     {   0,
-        0,    0,    0,    0,  122,  481,  481,  481,   38,  481,
-      481,  481,  481,   31,  481,   35,  481,   33,  481,   93,
-       40,   42,   44,   48,   46,   50,   55,   61,   68,   75,
-       77,   79,   81,   83,   85,   92,  100,  481,   98,   96,
-      111,  104,  107,  481,  481,  481,    0,  114,  116,  118,
-      120,  122,  127,  131,  133,  138,  135,  141,  143,  145,
-      159,  147,  151,  164,  171,  166,  173,  177,  189,  179,
-      175,  199,  193,  201,  203,  205,  207,  209,  212,  219,
-      223,  232,  234,  236,  238,  240,  244,  246,  249,  251,
-      263,  265,  267,  269,  273,  275,  278,  280,  284,  288,
-
-      298,  292,  296,  301,  303,  305,  307,  312,  316,  318,
-      320,  322,  324,  328,  330,  332,  334,  337,  339,  341,
-      343,  352,  354,  359,  361,  363,  365,   68,  367,  370,
-      376,  378,  380,  382,  389,  391,  395,  397,  402,  404,
-      406,  408,  418,  411,  416,  422,  426,  430,  432,  434,
-      436,  438,  441,  451,  444,  454,  132,  449,  461,   81,
-       71,  481,  475,  477,   63,   44
+        0,    0,    0,    0,  282,  283,  283,  283,  276,  283,
+      283,  283,  283,  267,  283,   31,  283,   29,  283,  263,
+       30,   34,   35,   36,   37,   39,  265,   40,   44,   42,
+       50,   46,   58,   66,   52,   69,   51,  283,  272,  271,
+       75,  262,  283,  283,  283,    0,  261,   76,   77,   78,
+       79,   80,   59,   81,   85,   87,   90,   91,   92,  105,
+       93,  260,   95,  101,   99,   94,  114,  121,  106,  107,
+      259,  258,  119,  102,  125,  126,  130,  134,  133,  136,
+      137,  139,  138,  141,  145,  146,  148,  147,  150,  149,
+      153,  257,  151,  163,  152,  164,  167,  171,  172,  256,
+
+      173,  174,  255,  175,  254,  253,  252,  176,  251,  250,
+      178,  179,  180,  249,  248,  181,  182,  247,  246,  184,
+      183,  185,  200,  245,  188,  203,  204,  238,  237,  207,
+      196,  210,  202,  208,  214,  217,  236,  235,  234,  233,
+      232,  231,  220,  229,  228,  226,  224,   38,  222,  283,
+      252,  254,  231,  228
     } ;
 
-static const flex_int16_t yy_def[167] =
+static yyconst flex_int16_t yy_def[155] =
     {   0,
-      162,    1,  163,  163,  162,  162,  162,  162,  164,  162,
-      162,  162,  162,  162,  162,  162,  162,  162,  162,  162,
-      165,  165,  165,  165,  165,  165,  165,  165,  165,  165,
-      165,  165,  165,  165,  165,  165,  165,  162,  164,  164,
-      164,  162,  162,  162,  162,  162,  166,  165,  165,  165,
-      165,  165,  165,  165,  165,  165,  165,  165,  165,  165,
-      165,  165,  165,  165,  165,  165,  165,  165,  165,  165,
-      165,  164,  162,  165,  165,  165,  165,  165,  165,  165,
-      165,  165,  165,  165,  165,  165,  165,  165,  165,  165,
-      165,  165,  165,  165,  165,  165,  165,  165,  165,  165,
-
-      164,  165,  165,  165,  165,  165,  165,  165,  165,  165,
-      165,  165,  165,  165,  165,  165,  165,  165,  165,  165,
-      165,  165,  165,  165,  165,  165,  165,  164,  165,  165,
-      165,  165,  165,  165,  165,  165,  165,  165,  165,  165,
-      165,  165,  164,  165,  165,  165,  165,  165,  165,  165,
-      165,  165,  165,  164,  165,  164,  164,  165,  164,  164,
-      164,    0,  162,  162,  162,  162
+      150,    1,  151,  151,  150,  150,  150,  150,  152,  150,
+      150,  150,  150,  150,  150,  150,  150,  150,  150,  150,
+      153,  153,  153,  153,  153,  153,  153,  153,  153,  153,
+      153,  153,  153,  153,  153,  153,  153,  150,  152,  152,
+      150,  150,  150,  150,  150,  154,  153,  153,  153,  153,
+      153,  153,  153,  153,  153,  153,  153,  153,  153,  153,
+      153,  153,  153,  153,  153,  153,  153,  153,  153,  153,
+      150,  153,  153,  153,  153,  153,  153,  153,  153,  153,
+      153,  153,  153,  153,  153,  153,  153,  153,  153,  153,
+      153,  153,  153,  153,  153,  153,  153,  153,  153,  153,
+
+      153,  153,  153,  153,  153,  153,  153,  153,  153,  153,
+      153,  153,  153,  153,  153,  153,  153,  153,  153,  153,
+      153,  153,  153,  153,  153,  153,  153,  153,  153,  153,
+      153,  153,  153,  153,  153,  153,  153,  153,  153,  153,
+      153,  153,  153,  153,  153,  153,  153,  153,  153,    0,
+      150,  150,  150,  150
     } ;
 
-static const flex_int16_t yy_nxt[524] =
+static yyconst flex_int16_t yy_nxt[325] =
     {   0,
         6,    7,    8,    7,    9,   10,   11,   12,   13,   14,
-       15,    6,   16,   16,   17,   18,   19,   20,   21,   22,
-       23,   24,   25,   26,   27,   28,   29,   27,   27,   30,
-       27,   27,   31,   27,   32,   33,   34,   35,   36,   37,
-       27,   27,   40,   42,   42,   43,   47,   42,   42,   44,
-       45,   41,   47,   47,   47,   47,   47,   47,   47,   47,
-       47,   47,   47,   47,   50,   48,   54,   47,   47,   51,
-       55,   49,   40,   47,   47,  160,   52,  143,   53,   58,
-       47,   47,   56,   60,   59,   40,   57,   47,   47,   47,
-       47,   47,   47,   47,   47,   47,   47,   47,   47,   61,
-
-       40,   68,   40,   65,   47,   47,   66,   62,   63,   46,
-       70,   64,   47,   47,   43,   40,   42,   42,   69,   73,
-       73,  162,   67,   72,   72,   71,   47,   47,   47,   47,
-       47,   47,   47,   47,   47,   47,   40,   74,   76,   47,
-       47,  156,   75,   47,   47,   47,   47,   47,   47,   78,
-       47,   47,   77,   47,   47,   47,   47,   47,   47,   47,
-       47,   83,   80,   47,   47,   91,  162,   79,   81,  162,
-       82,   47,   47,   84,   86,   85,   47,   47,   47,   47,
-       87,  162,   88,   47,   47,   47,   47,   47,   47,   47,
-       47,   47,   47,   92,   89,   90,   97,  100,   95,  162,
-
-       93,   47,   47,   40,   96,   73,   73,   94,   99,  162,
-       98,  101,  101,   47,   47,   47,   47,   47,   47,   47,
-       47,   47,   47,  162,   47,   47,  162,  105,  162,  102,
-      106,   47,   47,  162,  107,   47,   47,  104,  162,  103,
-      162,  108,  162,  109,   47,   47,   47,   47,   47,   47,
-       47,   47,   47,   47,  112,  162,   47,   47,   47,   47,
-      162,   47,   47,   47,   47,  110,  115,  162,  113,  162,
-      111,  117,  116,  114,  162,   47,   47,   47,   47,   47,
-       47,   47,   47,  118,  119,   47,   47,   47,   47,  121,
-       47,   47,   47,   47,  120,  123,   47,   47,  125,  162,
-
-       47,   47,   40,  162,   47,   47,  162,  124,   47,   47,
-      128,  128,  122,   47,   47,   47,   47,   47,   47,   47,
-       47,  126,  127,  129,   47,   47,  162,  130,   47,   47,
-       47,   47,   47,   47,   47,   47,   47,   47,  162,  131,
-       47,   47,   47,   47,   47,   47,   47,   47,  132,   47,
-       47,   47,   47,   47,   47,   47,   47,  162,  133,  162,
-      137,  135,  162,  138,   47,   47,   47,   47,  136,  162,
-      134,   47,   47,   47,   47,   47,   47,   47,   47,   47,
-       47,  139,   47,   47,  162,  141,  162,  142,   47,   47,
-       47,   47,   47,   47,   47,   47,  162,  140,  145,  162,
-
-      146,   47,   47,   47,   47,  162,  144,   47,   47,   47,
-       47,  147,  162,  149,   47,   47,   47,   47,   47,   47,
-       47,   47,   40,   47,   47,  162,  152,  148,   47,   47,
-      154,  154,  162,  150,   47,   47,  162,  151,   47,   47,
-      162,  153,   47,   47,   47,   47,   47,   47,   47,   47,
-       47,   47,  155,   47,   47,   40,   47,   47,   40,  162,
-      156,   47,   47,  157,  157,  160,  159,  159,  162,  162,
-      162,  162,  158,  161,  161,   38,   38,   38,   39,   39,
-        5,  162,  162,  162,  162,  162,  162,  162,  162,  162,
-      162,  162,  162,  162,  162,  162,  162,  162,  162,  162,
-
-      162,  162,  162,  162,  162,  162,  162,  162,  162,  162,
-      162,  162,  162,  162,  162,  162,  162,  162,  162,  162,
-      162,  162,  162
+       15,    6,   16,   17,   18,   19,   20,   21,   22,   23,
+       24,   25,   26,   27,   28,   29,   27,   27,   30,   27,
+       27,   31,   27,   32,   33,   34,   35,   36,   37,   27,
+       27,   42,   46,   41,   43,   44,   46,   46,   46,   46,
+       46,   46,   46,   53,   46,   49,   46,   54,   46,   50,
+       48,   59,   46,   46,   46,  149,   51,   57,   52,   55,
+       46,   46,   58,   61,   60,   70,   56,   63,   46,   64,
+       62,   46,   65,   67,   68,   42,   69,   41,   46,   46,
+       46,   46,   46,   46,   77,   74,   72,   46,   66,   46,
+
+       73,   76,   46,   46,   46,   46,   46,   46,   75,   78,
+       89,   46,   81,   46,   46,   79,   80,   46,   46,   46,
+       84,   82,   83,   90,   94,   85,   46,   86,   98,   91,
+       93,   46,   95,   46,   97,  100,   92,   46,   46,   87,
+       88,   96,   46,  102,   99,   46,   46,  103,   46,   46,
+       46,   46,  105,   46,  101,  104,  108,   46,   46,   46,
+       46,   46,   46,   46,   46,   46,  111,  109,  106,  113,
+      115,  112,  107,  110,  117,   46,   46,  116,  114,   46,
+      120,  121,  119,   46,   46,   46,   46,   46,   46,  118,
+       46,   46,   46,   46,   46,   46,   46,   46,  125,  132,
+
+       46,  133,  124,  122,  123,  134,  136,  130,   46,  126,
+      127,  128,   46,  131,   46,   46,   46,  129,  135,   46,
+       46,  137,   46,  138,  139,  140,   46,  143,  141,   46,
+       46,  142,   46,   47,   46,  146,   46,  144,   46,  148,
+       46,   46,  145,   46,   46,   46,   46,   46,   46,   46,
+       46,  147,   38,   38,   38,   39,   39,   46,   46,   46,
+       46,   46,   46,   46,   46,   46,   46,   46,   46,   46,
+       46,   71,   46,   46,   71,   40,   40,   46,   45,   41,
+       40,  150,    5,  150,  150,  150,  150,  150,  150,  150,
+      150,  150,  150,  150,  150,  150,  150,  150,  150,  150,
+
+      150,  150,  150,  150,  150,  150,  150,  150,  150,  150,
+      150,  150,  150,  150,  150,  150,  150,  150,  150,  150,
+      150,  150,  150,  150
     } ;
 
-static const flex_int16_t yy_chk[524] =
+static yyconst flex_int16_t yy_chk[325] =
     {   0,
         1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
         1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
         1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
         1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
-        1,    1,    9,   14,   14,   16,  166,   16,   16,   18,
-       18,    9,   21,   21,   22,   22,   23,   23,   25,   25,
-       24,   24,   26,   26,   22,  165,   24,   27,   27,   23,
-       24,   21,  128,   28,   28,  161,   23,  128,   23,   26,
-       29,   29,   24,   28,   26,  160,   25,   30,   30,   31,
-       31,   32,   32,   33,   33,   34,   34,   35,   35,   29,
-
-       40,   34,   39,   33,   36,   36,   33,   30,   31,   20,
-       36,   32,   37,   37,   42,   41,   42,   42,   35,   43,
-       43,    5,   33,   41,   41,   37,   48,   48,   49,   49,
-       50,   50,   51,   51,   52,   52,  157,   49,   51,   53,
-       53,  157,   50,   54,   54,   55,   55,   57,   57,   53,
-       56,   56,   52,   58,   58,   59,   59,   60,   60,   62,
-       62,   57,   55,   63,   63,   62,    0,   54,   55,    0,
-       56,   61,   61,   58,   60,   59,   64,   64,   66,   66,
-       61,    0,   61,   65,   65,   67,   67,   71,   71,   68,
-       68,   70,   70,   64,   61,   61,   68,   71,   66,    0,
-
-       65,   69,   69,   72,   67,   73,   73,   65,   70,    0,
-       69,   72,   72,   74,   74,   75,   75,   76,   76,   77,
-       77,   78,   78,    0,   79,   79,    0,   78,    0,   75,
-       79,   80,   80,    0,   79,   81,   81,   77,    0,   76,
-        0,   80,    0,   81,   82,   82,   83,   83,   84,   84,
-       85,   85,   86,   86,   84,    0,   87,   87,   88,   88,
-        0,   89,   89,   90,   90,   82,   87,    0,   85,    0,
-       83,   89,   88,   86,    0,   91,   91,   92,   92,   93,
-       93,   94,   94,   90,   91,   95,   95,   96,   96,   93,
-       97,   97,   98,   98,   92,   96,   99,   99,   98,    0,
-
-      100,  100,  101,    0,  102,  102,    0,   97,  103,  103,
-      101,  101,   95,  104,  104,  105,  105,  106,  106,  107,
-      107,   99,  100,  102,  108,  108,    0,  104,  109,  109,
-      110,  110,  111,  111,  112,  112,  113,  113,    0,  105,
-      114,  114,  115,  115,  116,  116,  117,  117,  108,  118,
-      118,  119,  119,  120,  120,  121,  121,    0,  112,    0,
-      120,  116,    0,  121,  122,  122,  123,  123,  117,    0,
-      115,  124,  124,  125,  125,  126,  126,  127,  127,  129,
-      129,  124,  130,  130,    0,  126,    0,  127,  131,  131,
-      132,  132,  133,  133,  134,  134,    0,  125,  131,    0,
-
-      132,  135,  135,  136,  136,    0,  130,  137,  137,  138,
-      138,  135,    0,  137,  139,  139,  140,  140,  141,  141,
-      142,  142,  143,  144,  144,    0,  140,  136,  145,  145,
-      143,  143,    0,  138,  146,  146,    0,  139,  147,  147,
-        0,  141,  148,  148,  149,  149,  150,  150,  151,  151,
-      152,  152,  149,  153,  153,  154,  155,  155,  156,    0,
-      154,  158,  158,  154,  154,  159,  156,  156,    0,    0,
-        0,    0,  155,  159,  159,  163,  163,  163,  164,  164,
-      162,  162,  162,  162,  162,  162,  162,  162,  162,  162,
-      162,  162,  162,  162,  162,  162,  162,  162,  162,  162,
-
-      162,  162,  162,  162,  162,  162,  162,  162,  162,  162,
-      162,  162,  162,  162,  162,  162,  162,  162,  162,  162,
-      162,  162,  162
+        1,   16,   21,   16,   18,   18,   22,   23,   24,   25,
+      148,   26,   28,   24,   30,   22,   29,   24,   32,   23,
+       21,   28,   31,   37,   35,  148,   23,   26,   23,   24,
+       33,   53,   26,   30,   29,   37,   25,   32,   34,   33,
+       31,   36,   33,   34,   35,   41,   36,   41,   48,   49,
+       50,   51,   52,   54,   53,   50,   48,   55,   33,   56,
+
+       49,   52,   57,   58,   59,   61,   66,   63,   51,   54,
+       61,   65,   56,   64,   74,   54,   55,   60,   69,   70,
+       59,   57,   58,   63,   66,   60,   67,   60,   70,   64,
+       65,   73,   67,   68,   69,   74,   64,   75,   76,   60,
+       60,   68,   77,   76,   73,   79,   78,   77,   80,   81,
+       83,   82,   79,   84,   75,   78,   82,   85,   86,   88,
+       87,   90,   89,   93,   95,   91,   85,   83,   80,   87,
+       89,   86,   81,   84,   91,   94,   96,   90,   88,   97,
+       95,   96,   94,   98,   99,  101,  102,  104,  108,   93,
+      111,  112,  113,  116,  117,  121,  120,  122,  101,  116,
+
+      125,  117,   99,   97,   98,  120,  122,  112,  131,  102,
+      104,  108,  123,  113,  133,  126,  127,  111,  121,  130,
+      134,  123,  132,  125,  126,  127,  135,  132,  130,  136,
+      154,  131,  143,  153,  149,  135,  147,  133,  146,  143,
+      145,  144,  134,  142,  141,  140,  139,  138,  137,  129,
+      128,  136,  151,  151,  151,  152,  152,  124,  119,  118,
+      115,  114,  110,  109,  107,  106,  105,  103,  100,   92,
+       72,   71,   62,   47,   42,   40,   39,   27,   20,   14,
+        9,    5,  150,  150,  150,  150,  150,  150,  150,  150,
+      150,  150,  150,  150,  150,  150,  150,  150,  150,  150,
+
+      150,  150,  150,  150,  150,  150,  150,  150,  150,  150,
+      150,  150,  150,  150,  150,  150,  150,  150,  150,  150,
+      150,  150,  150,  150
     } ;
 
 /* The intent behind this definition is that it'll catch
@@ -615,10 +566,9 @@ extern double atof();
 #endif // YYDEBUG
 
 #define RETURN_TOKEN(token) debug_printf("%s\n",#token);return token
-#line 619 "lex.yy.c"
 /* Prevent the need for linking with -lfl */
 
-#line 622 "lex.yy.c"
+#line 572 "lex.yy.c"
 
 #define INITIAL 0
 #define STR 1
@@ -648,8 +598,8 @@ struct yyguts_t
     size_t yy_buffer_stack_max; /**< capacity of stack. */
     YY_BUFFER_STATE * yy_buffer_stack; /**< Stack as an array. */
     char yy_hold_char;
-    int yy_n_chars;
-    int yyleng_r;
+    yy_size_t yy_n_chars;
+    yy_size_t yyleng_r;
     char *yy_c_buf_p;
     int yy_init;
     int yy_start;
@@ -671,7 +621,7 @@ struct yyguts_t
 
     }; /* end struct yyguts_t */
 
-static int yy_init_globals ( yyscan_t yyscanner );
+static int yy_init_globals (yyscan_t yyscanner );
 
     /* This must go here because YYSTYPE and YYLTYPE are included
      * from bison output in section 1.*/
@@ -679,44 +629,40 @@ static int yy_init_globals ( yyscan_t yyscanner );
     
 int yylex_init (yyscan_t* scanner);
 
-int yylex_init_extra ( YY_EXTRA_TYPE user_defined, yyscan_t* scanner);
+int yylex_init_extra (YY_EXTRA_TYPE user_defined,yyscan_t* scanner);
 
 /* Accessor methods to globals.
    These are made visible to non-reentrant scanners for convenience. */
 
-int yylex_destroy ( yyscan_t yyscanner );
-
-int yyget_debug ( yyscan_t yyscanner );
-
-void yyset_debug ( int debug_flag , yyscan_t yyscanner );
+int yylex_destroy (yyscan_t yyscanner );
 
-YY_EXTRA_TYPE yyget_extra ( yyscan_t yyscanner );
+int yyget_debug (yyscan_t yyscanner );
 
-void yyset_extra ( YY_EXTRA_TYPE user_defined , yyscan_t yyscanner );
+void yyset_debug (int debug_flag ,yyscan_t yyscanner );
 
-FILE *yyget_in ( yyscan_t yyscanner );
+YY_EXTRA_TYPE yyget_extra (yyscan_t yyscanner );
 
-void yyset_in  ( FILE * _in_str , yyscan_t yyscanner );
+void yyset_extra (YY_EXTRA_TYPE user_defined ,yyscan_t yyscanner );
 
-FILE *yyget_out ( yyscan_t yyscanner );
+FILE *yyget_in (yyscan_t yyscanner );
 
-void yyset_out  ( FILE * _out_str , yyscan_t yyscanner );
+void yyset_in  (FILE * in_str ,yyscan_t yyscanner );
 
-			int yyget_leng ( yyscan_t yyscanner );
+FILE *yyget_out (yyscan_t yyscanner );
 
-char *yyget_text ( yyscan_t yyscanner );
+void yyset_out  (FILE * out_str ,yyscan_t yyscanner );
 
-int yyget_lineno ( yyscan_t yyscanner );
+yy_size_t yyget_leng (yyscan_t yyscanner );
 
-void yyset_lineno ( int _line_number , yyscan_t yyscanner );
+char *yyget_text (yyscan_t yyscanner );
 
-int yyget_column  ( yyscan_t yyscanner );
+int yyget_lineno (yyscan_t yyscanner );
 
-void yyset_column ( int _column_no , yyscan_t yyscanner );
+void yyset_lineno (int line_number ,yyscan_t yyscanner );
 
-YYSTYPE * yyget_lval ( yyscan_t yyscanner );
+YYSTYPE * yyget_lval (yyscan_t yyscanner );
 
-void yyset_lval ( YYSTYPE * yylval_param , yyscan_t yyscanner );
+void yyset_lval (YYSTYPE * yylval_param ,yyscan_t yyscanner );
 
 /* Macros after this point can all be overridden by user definitions in
  * section 1.
@@ -724,43 +670,35 @@ void yyset_lval ( YYSTYPE * yylval_param , yyscan_t yyscanner );
 
 #ifndef YY_SKIP_YYWRAP
 #ifdef __cplusplus
-extern "C" int yywrap ( yyscan_t yyscanner );
+extern "C" int yywrap (yyscan_t yyscanner );
 #else
-extern int yywrap ( yyscan_t yyscanner );
+extern int yywrap (yyscan_t yyscanner );
 #endif
 #endif
 
-#ifndef YY_NO_UNPUT
+    static void yyunput (int c,char *buf_ptr  ,yyscan_t yyscanner);
     
-    static void yyunput ( int c, char *buf_ptr  , yyscan_t yyscanner);
-    
-#endif
-
 #ifndef yytext_ptr
-static void yy_flex_strncpy ( char *, const char *, int , yyscan_t yyscanner);
+static void yy_flex_strncpy (char *,yyconst char *,int ,yyscan_t yyscanner);
 #endif
 
 #ifdef YY_NEED_STRLEN
-static int yy_flex_strlen ( const char * , yyscan_t yyscanner);
+static int yy_flex_strlen (yyconst char * ,yyscan_t yyscanner);
 #endif
 
 #ifndef YY_NO_INPUT
+
 #ifdef __cplusplus
-static int yyinput ( yyscan_t yyscanner );
+static int yyinput (yyscan_t yyscanner );
 #else
-static int input ( yyscan_t yyscanner );
+static int input (yyscan_t yyscanner );
 #endif
 
 #endif
 
 /* Amount of stuff to slurp up with each read. */
 #ifndef YY_READ_BUF_SIZE
-#ifdef __ia64__
-/* On IA-64, the buffer size is 16k, not 8k */
-#define YY_READ_BUF_SIZE 16384
-#else
 #define YY_READ_BUF_SIZE 8192
-#endif /* __ia64__ */
 #endif
 
 /* Copy whatever the last rule matched to the standard output. */
@@ -768,7 +706,7 @@ static int input ( yyscan_t yyscanner );
 /* This used to be an fputs(), but since the string might contain NUL's,
  * we now use fwrite().
  */
-#define ECHO do { if (fwrite( yytext, (size_t) yyleng, 1, yyout )) {} } while (0)
+#define ECHO fwrite( yytext, yyleng, 1, yyout )
 #endif
 
 /* Gets input and stuffs it into "buf".  number of characters read, or YY_NULL,
@@ -779,7 +717,7 @@ static int input ( yyscan_t yyscanner );
 	if ( YY_CURRENT_BUFFER_LVALUE->yy_is_interactive ) \
 		{ \
 		int c = '*'; \
-		int n; \
+		yy_size_t n; \
 		for ( n = 0; n < max_size && \
 			     (c = getc( yyin )) != EOF && c != '\n'; ++n ) \
 			buf[n] = (char) c; \
@@ -792,7 +730,7 @@ static int input ( yyscan_t yyscanner );
 	else \
 		{ \
 		errno=0; \
-		while ( (result = (int) fread(buf, 1, (yy_size_t) max_size, yyin)) == 0 && ferror(yyin)) \
+		while ( (result = fread(buf, 1, max_size, yyin))==0 && ferror(yyin)) \
 			{ \
 			if( errno != EINTR) \
 				{ \
@@ -834,7 +772,7 @@ static int input ( yyscan_t yyscanner );
 #define YY_DECL_IS_OURS 1
 
 extern int yylex \
-               (YYSTYPE * yylval_param , yyscan_t yyscanner);
+               (YYSTYPE * yylval_param ,yyscan_t yyscanner);
 
 #define YY_DECL int yylex \
                (YYSTYPE * yylval_param , yyscan_t yyscanner)
@@ -849,7 +787,7 @@ extern int yylex \
 
 /* Code executed at the end of each rule. */
 #ifndef YY_BREAK
-#define YY_BREAK /*LINTED*/break;
+#define YY_BREAK break;
 #endif
 
 #define YY_RULE_SETUP \
@@ -859,11 +797,16 @@ extern int yylex \
  */
 YY_DECL
 {
-	yy_state_type yy_current_state;
-	char *yy_cp, *yy_bp;
-	int yy_act;
+	register yy_state_type yy_current_state;
+	register char *yy_cp, *yy_bp;
+	register int yy_act;
     struct yyguts_t * yyg = (struct yyguts_t*)yyscanner;
 
+#line 33 "lex_sql.l"
+
+
+#line 809 "lex.yy.c"
+
     yylval = yylval_param;
 
 	if ( !yyg->yy_init )
@@ -886,19 +829,13 @@ YY_DECL
 		if ( ! YY_CURRENT_BUFFER ) {
 			yyensure_buffer_stack (yyscanner);
 			YY_CURRENT_BUFFER_LVALUE =
-				yy_create_buffer( yyin, YY_BUF_SIZE , yyscanner);
+				yy_create_buffer(yyin,YY_BUF_SIZE ,yyscanner);
 		}
 
-		yy_load_buffer_state( yyscanner );
+		yy_load_buffer_state(yyscanner );
 		}
 
-	{
-#line 34 "lex_sql.l"
-
-
-#line 900 "lex.yy.c"
-
-	while ( /*CONSTCOND*/1 )		/* loops until end-of-file is reached */
+	while ( 1 )		/* loops until end-of-file is reached */
 		{
 		yy_cp = yyg->yy_c_buf_p;
 
@@ -914,7 +851,7 @@ YY_DECL
 yy_match:
 		do
 			{
-			YY_CHAR yy_c = yy_ec[YY_SC_TO_UI(*yy_cp)] ;
+			register YY_CHAR yy_c = yy_ec[YY_SC_TO_UI(*yy_cp)];
 			if ( yy_accept[yy_current_state] )
 				{
 				yyg->yy_last_accepting_state = yy_current_state;
@@ -923,13 +860,13 @@ yy_match:
 			while ( yy_chk[yy_base[yy_current_state] + yy_c] != yy_current_state )
 				{
 				yy_current_state = (int) yy_def[yy_current_state];
-				if ( yy_current_state >= 163 )
-					yy_c = yy_meta[yy_c];
+				if ( yy_current_state >= 151 )
+					yy_c = yy_meta[(unsigned int) yy_c];
 				}
-			yy_current_state = yy_nxt[yy_base[yy_current_state] + yy_c];
+			yy_current_state = yy_nxt[yy_base[yy_current_state] + (unsigned int) yy_c];
 			++yy_cp;
 			}
-		while ( yy_base[yy_current_state] != 481 );
+		while ( yy_base[yy_current_state] != 283 );
 
 yy_find_action:
 		yy_act = yy_accept[yy_current_state];
@@ -955,266 +892,256 @@ do_action:	/* This label is used only to access EOF actions. */
 
 case 1:
 YY_RULE_SETUP
-#line 36 "lex_sql.l"
+#line 35 "lex_sql.l"
 // ignore whitespace
 	YY_BREAK
 case 2:
 /* rule 2 can match eol */
 YY_RULE_SETUP
-#line 37 "lex_sql.l"
+#line 36 "lex_sql.l"
 ;
 	YY_BREAK
 case 3:
 YY_RULE_SETUP
-#line 39 "lex_sql.l"
+#line 38 "lex_sql.l"
 yylval->number=atoi(yytext); RETURN_TOKEN(NUMBER);
 	YY_BREAK
 case 4:
 YY_RULE_SETUP
-#line 40 "lex_sql.l"
+#line 39 "lex_sql.l"
 yylval->floats=(float)(atof(yytext)); RETURN_TOKEN(FLOAT);
 	YY_BREAK
 case 5:
 YY_RULE_SETUP
 #line 41 "lex_sql.l"
-yylval->datestr=strdup(yytext); RETURN_TOKEN(DATE); //date字段的匹配
+RETURN_TOKEN(SEMICOLON);
 	YY_BREAK
 case 6:
 YY_RULE_SETUP
 #line 42 "lex_sql.l"
-RETURN_TOKEN(SEMICOLON);
+RETURN_TOKEN(DOT);
 	YY_BREAK
 case 7:
 YY_RULE_SETUP
 #line 43 "lex_sql.l"
-RETURN_TOKEN(DOT);
+RETURN_TOKEN(STAR);
 	YY_BREAK
 case 8:
 YY_RULE_SETUP
 #line 44 "lex_sql.l"
-RETURN_TOKEN(STAR);
+RETURN_TOKEN(EXIT);
 	YY_BREAK
 case 9:
 YY_RULE_SETUP
 #line 45 "lex_sql.l"
-RETURN_TOKEN(EXIT);
+RETURN_TOKEN(HELP);
 	YY_BREAK
 case 10:
 YY_RULE_SETUP
 #line 46 "lex_sql.l"
-RETURN_TOKEN(HELP);
+RETURN_TOKEN(DESC);
 	YY_BREAK
 case 11:
 YY_RULE_SETUP
 #line 47 "lex_sql.l"
-RETURN_TOKEN(DESC);
+RETURN_TOKEN(CREATE);
 	YY_BREAK
 case 12:
 YY_RULE_SETUP
 #line 48 "lex_sql.l"
-RETURN_TOKEN(CREATE);
+RETURN_TOKEN(DROP);
 	YY_BREAK
 case 13:
 YY_RULE_SETUP
 #line 49 "lex_sql.l"
-RETURN_TOKEN(DROP);
+RETURN_TOKEN(TABLE);
 	YY_BREAK
 case 14:
 YY_RULE_SETUP
 #line 50 "lex_sql.l"
-RETURN_TOKEN(TABLE);
+RETURN_TOKEN(TABLES);
 	YY_BREAK
 case 15:
 YY_RULE_SETUP
 #line 51 "lex_sql.l"
-RETURN_TOKEN(TABLES);
+RETURN_TOKEN(INDEX);
 	YY_BREAK
 case 16:
 YY_RULE_SETUP
 #line 52 "lex_sql.l"
-RETURN_TOKEN(INDEX);
+RETURN_TOKEN(ON);
 	YY_BREAK
 case 17:
 YY_RULE_SETUP
 #line 53 "lex_sql.l"
-RETURN_TOKEN(ON);
+RETURN_TOKEN(SHOW);
 	YY_BREAK
 case 18:
 YY_RULE_SETUP
 #line 54 "lex_sql.l"
-RETURN_TOKEN(SHOW);
+RETURN_TOKEN(SYNC);
 	YY_BREAK
 case 19:
 YY_RULE_SETUP
 #line 55 "lex_sql.l"
-RETURN_TOKEN(SYNC);
+RETURN_TOKEN(SELECT);
 	YY_BREAK
 case 20:
 YY_RULE_SETUP
 #line 56 "lex_sql.l"
-RETURN_TOKEN(SELECT);
+RETURN_TOKEN(FROM);
 	YY_BREAK
 case 21:
 YY_RULE_SETUP
 #line 57 "lex_sql.l"
-RETURN_TOKEN(FROM);
+RETURN_TOKEN(WHERE);
 	YY_BREAK
 case 22:
 YY_RULE_SETUP
 #line 58 "lex_sql.l"
-RETURN_TOKEN(WHERE);
+RETURN_TOKEN(AND);
 	YY_BREAK
 case 23:
 YY_RULE_SETUP
 #line 59 "lex_sql.l"
-RETURN_TOKEN(AND);
+RETURN_TOKEN(INSERT);
 	YY_BREAK
 case 24:
 YY_RULE_SETUP
 #line 60 "lex_sql.l"
-RETURN_TOKEN(INSERT);
+RETURN_TOKEN(INTO);
 	YY_BREAK
 case 25:
 YY_RULE_SETUP
 #line 61 "lex_sql.l"
-RETURN_TOKEN(INTO);
+RETURN_TOKEN(VALUES);
 	YY_BREAK
 case 26:
 YY_RULE_SETUP
 #line 62 "lex_sql.l"
-RETURN_TOKEN(VALUES);
+RETURN_TOKEN(DELETE);
 	YY_BREAK
 case 27:
 YY_RULE_SETUP
 #line 63 "lex_sql.l"
-RETURN_TOKEN(DELETE);
+RETURN_TOKEN(UPDATE);
 	YY_BREAK
 case 28:
 YY_RULE_SETUP
 #line 64 "lex_sql.l"
-RETURN_TOKEN(UPDATE);
+RETURN_TOKEN(SET);
 	YY_BREAK
 case 29:
 YY_RULE_SETUP
 #line 65 "lex_sql.l"
-RETURN_TOKEN(SET);
+RETURN_TOKEN(TRX_BEGIN);
 	YY_BREAK
 case 30:
 YY_RULE_SETUP
 #line 66 "lex_sql.l"
-RETURN_TOKEN(TRX_BEGIN);
+RETURN_TOKEN(TRX_COMMIT);
 	YY_BREAK
 case 31:
 YY_RULE_SETUP
 #line 67 "lex_sql.l"
-RETURN_TOKEN(TRX_COMMIT);
+RETURN_TOKEN(TRX_ROLLBACK);
 	YY_BREAK
 case 32:
 YY_RULE_SETUP
 #line 68 "lex_sql.l"
-RETURN_TOKEN(TRX_ROLLBACK);
+RETURN_TOKEN(INT_T);
 	YY_BREAK
 case 33:
 YY_RULE_SETUP
 #line 69 "lex_sql.l"
-RETURN_TOKEN(INT_T);
+RETURN_TOKEN(STRING_T);
 	YY_BREAK
 case 34:
 YY_RULE_SETUP
 #line 70 "lex_sql.l"
-RETURN_TOKEN(STRING_T);
+RETURN_TOKEN(FLOAT_T);
 	YY_BREAK
 case 35:
 YY_RULE_SETUP
 #line 71 "lex_sql.l"
-RETURN_TOKEN(FLOAT_T);
+RETURN_TOKEN(LOAD);
 	YY_BREAK
 case 36:
 YY_RULE_SETUP
 #line 72 "lex_sql.l"
-RETURN_TOKEN(DATE_T);
+RETURN_TOKEN(DATA);
 	YY_BREAK
 case 37:
 YY_RULE_SETUP
 #line 73 "lex_sql.l"
-RETURN_TOKEN(LOAD);
+RETURN_TOKEN(INFILE);
 	YY_BREAK
 case 38:
 YY_RULE_SETUP
 #line 74 "lex_sql.l"
-RETURN_TOKEN(DATA);
+yylval->string=strdup(yytext); RETURN_TOKEN(ID);
 	YY_BREAK
 case 39:
 YY_RULE_SETUP
 #line 75 "lex_sql.l"
-RETURN_TOKEN(INFILE);
+RETURN_TOKEN(LBRACE);
 	YY_BREAK
 case 40:
 YY_RULE_SETUP
 #line 76 "lex_sql.l"
-yylval->string=strdup(yytext); RETURN_TOKEN(ID);
+RETURN_TOKEN(RBRACE);
 	YY_BREAK
 case 41:
 YY_RULE_SETUP
-#line 77 "lex_sql.l"
-RETURN_TOKEN(LBRACE);
+#line 78 "lex_sql.l"
+RETURN_TOKEN(COMMA);
 	YY_BREAK
 case 42:
 YY_RULE_SETUP
-#line 78 "lex_sql.l"
-RETURN_TOKEN(RBRACE);
+#line 79 "lex_sql.l"
+RETURN_TOKEN(EQ);
 	YY_BREAK
 case 43:
 YY_RULE_SETUP
 #line 80 "lex_sql.l"
-RETURN_TOKEN(COMMA);
+RETURN_TOKEN(LE);
 	YY_BREAK
 case 44:
 YY_RULE_SETUP
 #line 81 "lex_sql.l"
-RETURN_TOKEN(EQ);
+RETURN_TOKEN(NE);
 	YY_BREAK
 case 45:
 YY_RULE_SETUP
 #line 82 "lex_sql.l"
-RETURN_TOKEN(LE);
+RETURN_TOKEN(LT);
 	YY_BREAK
 case 46:
 YY_RULE_SETUP
 #line 83 "lex_sql.l"
-RETURN_TOKEN(NE);
+RETURN_TOKEN(GE);
 	YY_BREAK
 case 47:
 YY_RULE_SETUP
 #line 84 "lex_sql.l"
-RETURN_TOKEN(LT);
+RETURN_TOKEN(GT);
 	YY_BREAK
 case 48:
 YY_RULE_SETUP
 #line 85 "lex_sql.l"
-RETURN_TOKEN(GE);
+yylval->string=strdup(yytext); RETURN_TOKEN(SSS);
 	YY_BREAK
 case 49:
 YY_RULE_SETUP
-#line 86 "lex_sql.l"
-RETURN_TOKEN(GT);
-	YY_BREAK
-case 50:
-YY_RULE_SETUP
 #line 87 "lex_sql.l"
-yylval->string=strdup(yytext); RETURN_TOKEN(SSS);
-	YY_BREAK
-case 51:
-YY_RULE_SETUP
-#line 89 "lex_sql.l"
 printf("Unknown character [%c]\n",yytext[0]); return yytext[0];
 	YY_BREAK
-case 52:
+case 50:
 YY_RULE_SETUP
-#line 90 "lex_sql.l"
+#line 88 "lex_sql.l"
 ECHO;
 	YY_BREAK
-#line 1218 "lex.yy.c"
+#line 1145 "lex.yy.c"
 case YY_STATE_EOF(INITIAL):
 case YY_STATE_EOF(STR):
 	yyterminate();
@@ -1293,7 +1220,7 @@ case YY_STATE_EOF(STR):
 				{
 				yyg->yy_did_buffer_switch_on_eof = 0;
 
-				if ( yywrap( yyscanner ) )
+				if ( yywrap(yyscanner ) )
 					{
 					/* Note: because we've taken care in
 					 * yy_get_next_buffer() to have set up
@@ -1346,7 +1273,6 @@ case YY_STATE_EOF(STR):
 			"fatal flex scanner internal error--no action found" );
 	} /* end of action switch */
 		} /* end of scanning one token */
-	} /* end of user's declarations */
 } /* end of yylex */
 
 /* yy_get_next_buffer - try to read in a new buffer
@@ -1359,9 +1285,9 @@ case YY_STATE_EOF(STR):
 static int yy_get_next_buffer (yyscan_t yyscanner)
 {
     struct yyguts_t * yyg = (struct yyguts_t*)yyscanner;
-	char *dest = YY_CURRENT_BUFFER_LVALUE->yy_ch_buf;
-	char *source = yyg->yytext_ptr;
-	int number_to_move, i;
+	register char *dest = YY_CURRENT_BUFFER_LVALUE->yy_ch_buf;
+	register char *source = yyg->yytext_ptr;
+	register int number_to_move, i;
 	int ret_val;
 
 	if ( yyg->yy_c_buf_p > &YY_CURRENT_BUFFER_LVALUE->yy_ch_buf[yyg->yy_n_chars + 1] )
@@ -1390,7 +1316,7 @@ static int yy_get_next_buffer (yyscan_t yyscanner)
 	/* Try to read more data. */
 
 	/* First move last chars to start of buffer. */
-	number_to_move = (int) (yyg->yy_c_buf_p - yyg->yytext_ptr - 1);
+	number_to_move = (int) (yyg->yy_c_buf_p - yyg->yytext_ptr) - 1;
 
 	for ( i = 0; i < number_to_move; ++i )
 		*(dest++) = *(source++);
@@ -1403,21 +1329,21 @@ static int yy_get_next_buffer (yyscan_t yyscanner)
 
 	else
 		{
-			int num_to_read =
+			yy_size_t num_to_read =
 			YY_CURRENT_BUFFER_LVALUE->yy_buf_size - number_to_move - 1;
 
 		while ( num_to_read <= 0 )
 			{ /* Not enough room in the buffer - grow it. */
 
 			/* just a shorter name for the current buffer */
-			YY_BUFFER_STATE b = YY_CURRENT_BUFFER_LVALUE;
+			YY_BUFFER_STATE b = YY_CURRENT_BUFFER;
 
 			int yy_c_buf_p_offset =
 				(int) (yyg->yy_c_buf_p - b->yy_ch_buf);
 
 			if ( b->yy_is_our_buffer )
 				{
-				int new_size = b->yy_buf_size * 2;
+				yy_size_t new_size = b->yy_buf_size * 2;
 
 				if ( new_size <= 0 )
 					b->yy_buf_size += b->yy_buf_size / 8;
@@ -1426,12 +1352,11 @@ static int yy_get_next_buffer (yyscan_t yyscanner)
 
 				b->yy_ch_buf = (char *)
 					/* Include room in for 2 EOB chars. */
-					yyrealloc( (void *) b->yy_ch_buf,
-							 (yy_size_t) (b->yy_buf_size + 2) , yyscanner );
+					yyrealloc((void *) b->yy_ch_buf,b->yy_buf_size + 2 ,yyscanner );
 				}
 			else
 				/* Can't grow it, we don't own it. */
-				b->yy_ch_buf = NULL;
+				b->yy_ch_buf = 0;
 
 			if ( ! b->yy_ch_buf )
 				YY_FATAL_ERROR(
@@ -1459,7 +1384,7 @@ static int yy_get_next_buffer (yyscan_t yyscanner)
 		if ( number_to_move == YY_MORE_ADJ )
 			{
 			ret_val = EOB_ACT_END_OF_FILE;
-			yyrestart( yyin  , yyscanner);
+			yyrestart(yyin  ,yyscanner);
 			}
 
 		else
@@ -1473,15 +1398,12 @@ static int yy_get_next_buffer (yyscan_t yyscanner)
 	else
 		ret_val = EOB_ACT_CONTINUE_SCAN;
 
-	if ((yyg->yy_n_chars + number_to_move) > YY_CURRENT_BUFFER_LVALUE->yy_buf_size) {
+	if ((yy_size_t) (yyg->yy_n_chars + number_to_move) > YY_CURRENT_BUFFER_LVALUE->yy_buf_size) {
 		/* Extend the array by 50%, plus the number we really need. */
-		int new_size = yyg->yy_n_chars + number_to_move + (yyg->yy_n_chars >> 1);
-		YY_CURRENT_BUFFER_LVALUE->yy_ch_buf = (char *) yyrealloc(
-			(void *) YY_CURRENT_BUFFER_LVALUE->yy_ch_buf, (yy_size_t) new_size , yyscanner );
+		yy_size_t new_size = yyg->yy_n_chars + number_to_move + (yyg->yy_n_chars >> 1);
+		YY_CURRENT_BUFFER_LVALUE->yy_ch_buf = (char *) yyrealloc((void *) YY_CURRENT_BUFFER_LVALUE->yy_ch_buf,new_size ,yyscanner );
 		if ( ! YY_CURRENT_BUFFER_LVALUE->yy_ch_buf )
 			YY_FATAL_ERROR( "out of dynamic memory in yy_get_next_buffer()" );
-		/* "- 2" to take care of EOB's */
-		YY_CURRENT_BUFFER_LVALUE->yy_buf_size = (int) (new_size - 2);
 	}
 
 	yyg->yy_n_chars += number_to_move;
@@ -1497,15 +1419,15 @@ static int yy_get_next_buffer (yyscan_t yyscanner)
 
     static yy_state_type yy_get_previous_state (yyscan_t yyscanner)
 {
-	yy_state_type yy_current_state;
-	char *yy_cp;
+	register yy_state_type yy_current_state;
+	register char *yy_cp;
     struct yyguts_t * yyg = (struct yyguts_t*)yyscanner;
 
 	yy_current_state = yyg->yy_start;
 
 	for ( yy_cp = yyg->yytext_ptr + YY_MORE_ADJ; yy_cp < yyg->yy_c_buf_p; ++yy_cp )
 		{
-		YY_CHAR yy_c = (*yy_cp ? yy_ec[YY_SC_TO_UI(*yy_cp)] : 1);
+		register YY_CHAR yy_c = (*yy_cp ? yy_ec[YY_SC_TO_UI(*yy_cp)] : 1);
 		if ( yy_accept[yy_current_state] )
 			{
 			yyg->yy_last_accepting_state = yy_current_state;
@@ -1514,10 +1436,10 @@ static int yy_get_next_buffer (yyscan_t yyscanner)
 		while ( yy_chk[yy_base[yy_current_state] + yy_c] != yy_current_state )
 			{
 			yy_current_state = (int) yy_def[yy_current_state];
-			if ( yy_current_state >= 163 )
-				yy_c = yy_meta[yy_c];
+			if ( yy_current_state >= 151 )
+				yy_c = yy_meta[(unsigned int) yy_c];
 			}
-		yy_current_state = yy_nxt[yy_base[yy_current_state] + yy_c];
+		yy_current_state = yy_nxt[yy_base[yy_current_state] + (unsigned int) yy_c];
 		}
 
 	return yy_current_state;
@@ -1530,11 +1452,11 @@ static int yy_get_next_buffer (yyscan_t yyscanner)
  */
     static yy_state_type yy_try_NUL_trans  (yy_state_type yy_current_state , yyscan_t yyscanner)
 {
-	int yy_is_jam;
+	register int yy_is_jam;
     struct yyguts_t * yyg = (struct yyguts_t*)yyscanner; /* This var may be unused depending upon options. */
-	char *yy_cp = yyg->yy_c_buf_p;
+	register char *yy_cp = yyg->yy_c_buf_p;
 
-	YY_CHAR yy_c = 1;
+	register YY_CHAR yy_c = 1;
 	if ( yy_accept[yy_current_state] )
 		{
 		yyg->yy_last_accepting_state = yy_current_state;
@@ -1543,21 +1465,18 @@ static int yy_get_next_buffer (yyscan_t yyscanner)
 	while ( yy_chk[yy_base[yy_current_state] + yy_c] != yy_current_state )
 		{
 		yy_current_state = (int) yy_def[yy_current_state];
-		if ( yy_current_state >= 163 )
-			yy_c = yy_meta[yy_c];
+		if ( yy_current_state >= 151 )
+			yy_c = yy_meta[(unsigned int) yy_c];
 		}
-	yy_current_state = yy_nxt[yy_base[yy_current_state] + yy_c];
-	yy_is_jam = (yy_current_state == 162);
+	yy_current_state = yy_nxt[yy_base[yy_current_state] + (unsigned int) yy_c];
+	yy_is_jam = (yy_current_state == 150);
 
-	(void)yyg;
 	return yy_is_jam ? 0 : yy_current_state;
 }
 
-#ifndef YY_NO_UNPUT
-
-    static void yyunput (int c, char * yy_bp , yyscan_t yyscanner)
+    static void yyunput (int c, register char * yy_bp , yyscan_t yyscanner)
 {
-	char *yy_cp;
+	register char *yy_cp;
     struct yyguts_t * yyg = (struct yyguts_t*)yyscanner;
 
     yy_cp = yyg->yy_c_buf_p;
@@ -1568,10 +1487,10 @@ static int yy_get_next_buffer (yyscan_t yyscanner)
 	if ( yy_cp < YY_CURRENT_BUFFER_LVALUE->yy_ch_buf + 2 )
 		{ /* need to shift things up to make room */
 		/* +2 for EOB chars. */
-		int number_to_move = yyg->yy_n_chars + 2;
-		char *dest = &YY_CURRENT_BUFFER_LVALUE->yy_ch_buf[
+		register yy_size_t number_to_move = yyg->yy_n_chars + 2;
+		register char *dest = &YY_CURRENT_BUFFER_LVALUE->yy_ch_buf[
 					YY_CURRENT_BUFFER_LVALUE->yy_buf_size + 2];
-		char *source =
+		register char *source =
 				&YY_CURRENT_BUFFER_LVALUE->yy_ch_buf[number_to_move];
 
 		while ( source > YY_CURRENT_BUFFER_LVALUE->yy_ch_buf )
@@ -1580,7 +1499,7 @@ static int yy_get_next_buffer (yyscan_t yyscanner)
 		yy_cp += (int) (dest - source);
 		yy_bp += (int) (dest - source);
 		YY_CURRENT_BUFFER_LVALUE->yy_n_chars =
-			yyg->yy_n_chars = (int) YY_CURRENT_BUFFER_LVALUE->yy_buf_size;
+			yyg->yy_n_chars = YY_CURRENT_BUFFER_LVALUE->yy_buf_size;
 
 		if ( yy_cp < YY_CURRENT_BUFFER_LVALUE->yy_ch_buf + 2 )
 			YY_FATAL_ERROR( "flex scanner push-back overflow" );
@@ -1593,8 +1512,6 @@ static int yy_get_next_buffer (yyscan_t yyscanner)
 	yyg->yy_c_buf_p = yy_cp;
 }
 
-#endif
-
 #ifndef YY_NO_INPUT
 #ifdef __cplusplus
     static int yyinput (yyscan_t yyscanner)
@@ -1620,7 +1537,7 @@ static int yy_get_next_buffer (yyscan_t yyscanner)
 
 		else
 			{ /* need more input */
-			int offset = (int) (yyg->yy_c_buf_p - yyg->yytext_ptr);
+			yy_size_t offset = yyg->yy_c_buf_p - yyg->yytext_ptr;
 			++yyg->yy_c_buf_p;
 
 			switch ( yy_get_next_buffer( yyscanner ) )
@@ -1637,13 +1554,13 @@ static int yy_get_next_buffer (yyscan_t yyscanner)
 					 */
 
 					/* Reset buffer status. */
-					yyrestart( yyin , yyscanner);
+					yyrestart(yyin ,yyscanner);
 
 					/*FALLTHROUGH*/
 
 				case EOB_ACT_END_OF_FILE:
 					{
-					if ( yywrap( yyscanner ) )
+					if ( yywrap(yyscanner ) )
 						return 0;
 
 					if ( ! yyg->yy_did_buffer_switch_on_eof )
@@ -1682,11 +1599,11 @@ static int yy_get_next_buffer (yyscan_t yyscanner)
 	if ( ! YY_CURRENT_BUFFER ){
         yyensure_buffer_stack (yyscanner);
 		YY_CURRENT_BUFFER_LVALUE =
-            yy_create_buffer( yyin, YY_BUF_SIZE , yyscanner);
+            yy_create_buffer(yyin,YY_BUF_SIZE ,yyscanner);
 	}
 
-	yy_init_buffer( YY_CURRENT_BUFFER, input_file , yyscanner);
-	yy_load_buffer_state( yyscanner );
+	yy_init_buffer(YY_CURRENT_BUFFER,input_file ,yyscanner);
+	yy_load_buffer_state(yyscanner );
 }
 
 /** Switch to a different input buffer.
@@ -1715,7 +1632,7 @@ static int yy_get_next_buffer (yyscan_t yyscanner)
 		}
 
 	YY_CURRENT_BUFFER_LVALUE = new_buffer;
-	yy_load_buffer_state( yyscanner );
+	yy_load_buffer_state(yyscanner );
 
 	/* We don't actually know whether we did this switch during
 	 * EOF (yywrap()) processing, but the only time this flag
@@ -1744,7 +1661,7 @@ static void yy_load_buffer_state  (yyscan_t yyscanner)
 {
 	YY_BUFFER_STATE b;
     
-	b = (YY_BUFFER_STATE) yyalloc( sizeof( struct yy_buffer_state ) , yyscanner );
+	b = (YY_BUFFER_STATE) yyalloc(sizeof( struct yy_buffer_state ) ,yyscanner );
 	if ( ! b )
 		YY_FATAL_ERROR( "out of dynamic memory in yy_create_buffer()" );
 
@@ -1753,13 +1670,13 @@ static void yy_load_buffer_state  (yyscan_t yyscanner)
 	/* yy_ch_buf has to be 2 characters longer than the size given because
 	 * we need to put in 2 end-of-buffer characters.
 	 */
-	b->yy_ch_buf = (char *) yyalloc( (yy_size_t) (b->yy_buf_size + 2) , yyscanner );
+	b->yy_ch_buf = (char *) yyalloc(b->yy_buf_size + 2 ,yyscanner );
 	if ( ! b->yy_ch_buf )
 		YY_FATAL_ERROR( "out of dynamic memory in yy_create_buffer()" );
 
 	b->yy_is_our_buffer = 1;
 
-	yy_init_buffer( b, file , yyscanner);
+	yy_init_buffer(b,file ,yyscanner);
 
 	return b;
 }
@@ -1779,11 +1696,15 @@ static void yy_load_buffer_state  (yyscan_t yyscanner)
 		YY_CURRENT_BUFFER_LVALUE = (YY_BUFFER_STATE) 0;
 
 	if ( b->yy_is_our_buffer )
-		yyfree( (void *) b->yy_ch_buf , yyscanner );
+		yyfree((void *) b->yy_ch_buf ,yyscanner );
 
-	yyfree( (void *) b , yyscanner );
+	yyfree((void *) b ,yyscanner );
 }
 
+#ifndef __cplusplus
+extern int isatty (int );
+#endif /* __cplusplus */
+    
 /* Initializes or reinitializes a buffer.
  * This function is sometimes called more than once on the same buffer,
  * such as during a yyrestart() or at EOF.
@@ -1794,7 +1715,7 @@ static void yy_load_buffer_state  (yyscan_t yyscanner)
 	int oerrno = errno;
     struct yyguts_t * yyg = (struct yyguts_t*)yyscanner;
 
-	yy_flush_buffer( b , yyscanner);
+	yy_flush_buffer(b ,yyscanner);
 
 	b->yy_input_file = file;
 	b->yy_fill_buffer = 1;
@@ -1838,7 +1759,7 @@ static void yy_load_buffer_state  (yyscan_t yyscanner)
 	b->yy_buffer_status = YY_BUFFER_NEW;
 
 	if ( b == YY_CURRENT_BUFFER )
-		yy_load_buffer_state( yyscanner );
+		yy_load_buffer_state(yyscanner );
 }
 
 /** Pushes the new state onto the stack. The new state becomes
@@ -1870,7 +1791,7 @@ void yypush_buffer_state (YY_BUFFER_STATE new_buffer , yyscan_t yyscanner)
 	YY_CURRENT_BUFFER_LVALUE = new_buffer;
 
 	/* copied from yy_switch_to_buffer. */
-	yy_load_buffer_state( yyscanner );
+	yy_load_buffer_state(yyscanner );
 	yyg->yy_did_buffer_switch_on_eof = 1;
 }
 
@@ -1884,13 +1805,13 @@ void yypop_buffer_state (yyscan_t yyscanner)
 	if (!YY_CURRENT_BUFFER)
 		return;
 
-	yy_delete_buffer(YY_CURRENT_BUFFER , yyscanner);
+	yy_delete_buffer(YY_CURRENT_BUFFER ,yyscanner);
 	YY_CURRENT_BUFFER_LVALUE = NULL;
 	if (yyg->yy_buffer_stack_top > 0)
 		--yyg->yy_buffer_stack_top;
 
 	if (YY_CURRENT_BUFFER) {
-		yy_load_buffer_state( yyscanner );
+		yy_load_buffer_state(yyscanner );
 		yyg->yy_did_buffer_switch_on_eof = 1;
 	}
 }
@@ -1909,15 +1830,15 @@ static void yyensure_buffer_stack (yyscan_t yyscanner)
 		 * scanner will even need a stack. We use 2 instead of 1 to avoid an
 		 * immediate realloc on the next call.
          */
-      num_to_alloc = 1; /* After all that talk, this was set to 1 anyways... */
+		num_to_alloc = 1;
 		yyg->yy_buffer_stack = (struct yy_buffer_state**)yyalloc
 								(num_to_alloc * sizeof(struct yy_buffer_state*)
 								, yyscanner);
 		if ( ! yyg->yy_buffer_stack )
 			YY_FATAL_ERROR( "out of dynamic memory in yyensure_buffer_stack()" );
-
+								  
 		memset(yyg->yy_buffer_stack, 0, num_to_alloc * sizeof(struct yy_buffer_state*));
-
+				
 		yyg->yy_buffer_stack_max = num_to_alloc;
 		yyg->yy_buffer_stack_top = 0;
 		return;
@@ -1926,7 +1847,7 @@ static void yyensure_buffer_stack (yyscan_t yyscanner)
 	if (yyg->yy_buffer_stack_top >= (yyg->yy_buffer_stack_max) - 1){
 
 		/* Increase the buffer to prepare for a possible push. */
-		yy_size_t grow_size = 8 /* arbitrary grow size */;
+		int grow_size = 8 /* arbitrary grow size */;
 
 		num_to_alloc = yyg->yy_buffer_stack_max + grow_size;
 		yyg->yy_buffer_stack = (struct yy_buffer_state**)yyrealloc
@@ -1946,7 +1867,7 @@ static void yyensure_buffer_stack (yyscan_t yyscanner)
  * @param base the character buffer
  * @param size the size in bytes of the character buffer
  * @param yyscanner The scanner object.
- * @return the newly allocated buffer state object.
+ * @return the newly allocated buffer state object. 
  */
 YY_BUFFER_STATE yy_scan_buffer  (char * base, yy_size_t  size , yyscan_t yyscanner)
 {
@@ -1956,23 +1877,23 @@ YY_BUFFER_STATE yy_scan_buffer  (char * base, yy_size_t  size , yyscan_t yyscann
 	     base[size-2] != YY_END_OF_BUFFER_CHAR ||
 	     base[size-1] != YY_END_OF_BUFFER_CHAR )
 		/* They forgot to leave room for the EOB's. */
-		return NULL;
+		return 0;
 
-	b = (YY_BUFFER_STATE) yyalloc( sizeof( struct yy_buffer_state ) , yyscanner );
+	b = (YY_BUFFER_STATE) yyalloc(sizeof( struct yy_buffer_state ) ,yyscanner );
 	if ( ! b )
 		YY_FATAL_ERROR( "out of dynamic memory in yy_scan_buffer()" );
 
-	b->yy_buf_size = (int) (size - 2);	/* "- 2" to take care of EOB's */
+	b->yy_buf_size = size - 2;	/* "- 2" to take care of EOB's */
 	b->yy_buf_pos = b->yy_ch_buf = base;
 	b->yy_is_our_buffer = 0;
-	b->yy_input_file = NULL;
+	b->yy_input_file = 0;
 	b->yy_n_chars = b->yy_buf_size;
 	b->yy_is_interactive = 0;
 	b->yy_at_bol = 1;
 	b->yy_fill_buffer = 0;
 	b->yy_buffer_status = YY_BUFFER_NEW;
 
-	yy_switch_to_buffer( b , yyscanner );
+	yy_switch_to_buffer(b ,yyscanner );
 
 	return b;
 }
@@ -1985,29 +1906,28 @@ YY_BUFFER_STATE yy_scan_buffer  (char * base, yy_size_t  size , yyscan_t yyscann
  * @note If you want to scan bytes that may contain NUL values, then use
  *       yy_scan_bytes() instead.
  */
-YY_BUFFER_STATE yy_scan_string (const char * yystr , yyscan_t yyscanner)
+YY_BUFFER_STATE yy_scan_string (yyconst char * yystr , yyscan_t yyscanner)
 {
     
-	return yy_scan_bytes( yystr, (int) strlen(yystr) , yyscanner);
+	return yy_scan_bytes(yystr,strlen(yystr) ,yyscanner);
 }
 
 /** Setup the input buffer state to scan the given bytes. The next call to yylex() will
  * scan from a @e copy of @a bytes.
- * @param yybytes the byte buffer to scan
- * @param _yybytes_len the number of bytes in the buffer pointed to by @a bytes.
+ * @param bytes the byte buffer to scan
+ * @param len the number of bytes in the buffer pointed to by @a bytes.
  * @param yyscanner The scanner object.
  * @return the newly allocated buffer state object.
  */
-YY_BUFFER_STATE yy_scan_bytes  (const char * yybytes, int  _yybytes_len , yyscan_t yyscanner)
+YY_BUFFER_STATE yy_scan_bytes  (yyconst char * yybytes, yy_size_t  _yybytes_len , yyscan_t yyscanner)
 {
 	YY_BUFFER_STATE b;
 	char *buf;
-	yy_size_t n;
-	int i;
+	yy_size_t n, i;
     
 	/* Get memory for full buffer, including space for trailing EOB's. */
-	n = (yy_size_t) (_yybytes_len + 2);
-	buf = (char *) yyalloc( n , yyscanner );
+	n = _yybytes_len + 2;
+	buf = (char *) yyalloc(n ,yyscanner );
 	if ( ! buf )
 		YY_FATAL_ERROR( "out of dynamic memory in yy_scan_bytes()" );
 
@@ -2016,7 +1936,7 @@ YY_BUFFER_STATE yy_scan_bytes  (const char * yybytes, int  _yybytes_len , yyscan
 
 	buf[_yybytes_len] = buf[_yybytes_len+1] = YY_END_OF_BUFFER_CHAR;
 
-	b = yy_scan_buffer( buf, n , yyscanner);
+	b = yy_scan_buffer(buf,n ,yyscanner);
 	if ( ! b )
 		YY_FATAL_ERROR( "bad buffer in yy_scan_bytes()" );
 
@@ -2032,11 +1952,9 @@ YY_BUFFER_STATE yy_scan_bytes  (const char * yybytes, int  _yybytes_len , yyscan
 #define YY_EXIT_FAILURE 2
 #endif
 
-static void yynoreturn yy_fatal_error (const char* msg , yyscan_t yyscanner)
+static void yy_fatal_error (yyconst char* msg , yyscan_t yyscanner)
 {
-	struct yyguts_t * yyg = (struct yyguts_t*)yyscanner;
-	(void)yyg;
-	fprintf( stderr, "%s\n", msg );
+    	(void) fprintf( stderr, "%s\n", msg );
 	exit( YY_EXIT_FAILURE );
 }
 
@@ -2074,7 +1992,7 @@ YY_EXTRA_TYPE yyget_extra  (yyscan_t yyscanner)
 int yyget_lineno  (yyscan_t yyscanner)
 {
     struct yyguts_t * yyg = (struct yyguts_t*)yyscanner;
-
+    
         if (! YY_CURRENT_BUFFER)
             return 0;
     
@@ -2087,7 +2005,7 @@ int yyget_lineno  (yyscan_t yyscanner)
 int yyget_column  (yyscan_t yyscanner)
 {
     struct yyguts_t * yyg = (struct yyguts_t*)yyscanner;
-
+    
         if (! YY_CURRENT_BUFFER)
             return 0;
     
@@ -2115,7 +2033,7 @@ FILE *yyget_out  (yyscan_t yyscanner)
 /** Get the length of the current token.
  * @param yyscanner The scanner object.
  */
-int yyget_leng  (yyscan_t yyscanner)
+yy_size_t yyget_leng  (yyscan_t yyscanner)
 {
     struct yyguts_t * yyg = (struct yyguts_t*)yyscanner;
     return yyleng;
@@ -2142,51 +2060,51 @@ void yyset_extra (YY_EXTRA_TYPE  user_defined , yyscan_t yyscanner)
 }
 
 /** Set the current line number.
- * @param _line_number line number
+ * @param line_number
  * @param yyscanner The scanner object.
  */
-void yyset_lineno (int  _line_number , yyscan_t yyscanner)
+void yyset_lineno (int  line_number , yyscan_t yyscanner)
 {
     struct yyguts_t * yyg = (struct yyguts_t*)yyscanner;
 
         /* lineno is only valid if an input buffer exists. */
         if (! YY_CURRENT_BUFFER )
-           YY_FATAL_ERROR( "yyset_lineno called with no buffer" );
+           yy_fatal_error( "yyset_lineno called with no buffer" , yyscanner); 
     
-    yylineno = _line_number;
+    yylineno = line_number;
 }
 
 /** Set the current column.
- * @param _column_no column number
+ * @param line_number
  * @param yyscanner The scanner object.
  */
-void yyset_column (int  _column_no , yyscan_t yyscanner)
+void yyset_column (int  column_no , yyscan_t yyscanner)
 {
     struct yyguts_t * yyg = (struct yyguts_t*)yyscanner;
 
         /* column is only valid if an input buffer exists. */
         if (! YY_CURRENT_BUFFER )
-           YY_FATAL_ERROR( "yyset_column called with no buffer" );
+           yy_fatal_error( "yyset_column called with no buffer" , yyscanner); 
     
-    yycolumn = _column_no;
+    yycolumn = column_no;
 }
 
 /** Set the input stream. This does not discard the current
  * input buffer.
- * @param _in_str A readable stream.
+ * @param in_str A readable stream.
  * @param yyscanner The scanner object.
  * @see yy_switch_to_buffer
  */
-void yyset_in (FILE *  _in_str , yyscan_t yyscanner)
+void yyset_in (FILE *  in_str , yyscan_t yyscanner)
 {
     struct yyguts_t * yyg = (struct yyguts_t*)yyscanner;
-    yyin = _in_str ;
+    yyin = in_str ;
 }
 
-void yyset_out (FILE *  _out_str , yyscan_t yyscanner)
+void yyset_out (FILE *  out_str , yyscan_t yyscanner)
 {
     struct yyguts_t * yyg = (struct yyguts_t*)yyscanner;
-    yyout = _out_str ;
+    yyout = out_str ;
 }
 
 int yyget_debug  (yyscan_t yyscanner)
@@ -2195,10 +2113,10 @@ int yyget_debug  (yyscan_t yyscanner)
     return yy_flex_debug;
 }
 
-void yyset_debug (int  _bdebug , yyscan_t yyscanner)
+void yyset_debug (int  bdebug , yyscan_t yyscanner)
 {
     struct yyguts_t * yyg = (struct yyguts_t*)yyscanner;
-    yy_flex_debug = _bdebug ;
+    yy_flex_debug = bdebug ;
 }
 
 /* Accessor methods for yylval and yylloc */
@@ -2221,7 +2139,9 @@ void yyset_lval (YYSTYPE *  yylval_param , yyscan_t yyscanner)
  * the ONLY reentrant function that doesn't take the scanner as the last argument.
  * That's why we explicitly handle the declaration, instead of using our macros.
  */
+
 int yylex_init(yyscan_t* ptr_yy_globals)
+
 {
     if (ptr_yy_globals == NULL){
         errno = EINVAL;
@@ -2248,7 +2168,9 @@ int yylex_init(yyscan_t* ptr_yy_globals)
  * The user defined value in the first argument will be available to yyalloc in
  * the yyextra field.
  */
-int yylex_init_extra( YY_EXTRA_TYPE yy_user_defined, yyscan_t* ptr_yy_globals )
+
+int yylex_init_extra(YY_EXTRA_TYPE yy_user_defined,yyscan_t* ptr_yy_globals )
+
 {
     struct yyguts_t dummy_yyguts;
 
@@ -2258,20 +2180,20 @@ int yylex_init_extra( YY_EXTRA_TYPE yy_user_defined, yyscan_t* ptr_yy_globals )
         errno = EINVAL;
         return 1;
     }
-
+	
     *ptr_yy_globals = (yyscan_t) yyalloc ( sizeof( struct yyguts_t ), &dummy_yyguts );
-
+	
     if (*ptr_yy_globals == NULL){
         errno = ENOMEM;
         return 1;
     }
-
+    
     /* By setting to 0xAA, we expose bugs in
     yy_init_globals. Leave at 0x00 for releases. */
     memset(*ptr_yy_globals,0x00,sizeof(struct yyguts_t));
-
+    
     yyset_extra (yy_user_defined, *ptr_yy_globals);
-
+    
     return yy_init_globals ( *ptr_yy_globals );
 }
 
@@ -2282,10 +2204,10 @@ static int yy_init_globals (yyscan_t yyscanner)
      * This function is called from yylex_destroy(), so don't allocate here.
      */
 
-    yyg->yy_buffer_stack = NULL;
+    yyg->yy_buffer_stack = 0;
     yyg->yy_buffer_stack_top = 0;
     yyg->yy_buffer_stack_max = 0;
-    yyg->yy_c_buf_p = NULL;
+    yyg->yy_c_buf_p = (char *) 0;
     yyg->yy_init = 0;
     yyg->yy_start = 0;
 
@@ -2298,8 +2220,8 @@ static int yy_init_globals (yyscan_t yyscanner)
     yyin = stdin;
     yyout = stdout;
 #else
-    yyin = NULL;
-    yyout = NULL;
+    yyin = (FILE *) 0;
+    yyout = (FILE *) 0;
 #endif
 
     /* For future reference: Set errno on error, since we are called by
@@ -2315,17 +2237,17 @@ int yylex_destroy  (yyscan_t yyscanner)
 
     /* Pop the buffer stack, destroying each element. */
 	while(YY_CURRENT_BUFFER){
-		yy_delete_buffer( YY_CURRENT_BUFFER , yyscanner );
+		yy_delete_buffer(YY_CURRENT_BUFFER ,yyscanner );
 		YY_CURRENT_BUFFER_LVALUE = NULL;
 		yypop_buffer_state(yyscanner);
 	}
 
 	/* Destroy the stack itself. */
-	yyfree(yyg->yy_buffer_stack , yyscanner);
+	yyfree(yyg->yy_buffer_stack ,yyscanner);
 	yyg->yy_buffer_stack = NULL;
 
     /* Destroy the start condition stack. */
-        yyfree( yyg->yy_start_stack , yyscanner );
+        yyfree(yyg->yy_start_stack ,yyscanner );
         yyg->yy_start_stack = NULL;
 
     /* Reset the globals. This is important in a non-reentrant scanner so the next time
@@ -2343,21 +2265,18 @@ int yylex_destroy  (yyscan_t yyscanner)
  */
 
 #ifndef yytext_ptr
-static void yy_flex_strncpy (char* s1, const char * s2, int n , yyscan_t yyscanner)
+static void yy_flex_strncpy (char* s1, yyconst char * s2, int n , yyscan_t yyscanner)
 {
-	struct yyguts_t * yyg = (struct yyguts_t*)yyscanner;
-	(void)yyg;
-
-	int i;
+	register int i;
 	for ( i = 0; i < n; ++i )
 		s1[i] = s2[i];
 }
 #endif
 
 #ifdef YY_NEED_STRLEN
-static int yy_flex_strlen (const char * s , yyscan_t yyscanner)
+static int yy_flex_strlen (yyconst char * s , yyscan_t yyscanner)
 {
-	int n;
+	register int n;
 	for ( n = 0; s[n]; ++n )
 		;
 
@@ -2367,16 +2286,11 @@ static int yy_flex_strlen (const char * s , yyscan_t yyscanner)
 
 void *yyalloc (yy_size_t  size , yyscan_t yyscanner)
 {
-	struct yyguts_t * yyg = (struct yyguts_t*)yyscanner;
-	(void)yyg;
-	return malloc(size);
+	return (void *) malloc( size );
 }
 
 void *yyrealloc  (void * ptr, yy_size_t  size , yyscan_t yyscanner)
 {
-	struct yyguts_t * yyg = (struct yyguts_t*)yyscanner;
-	(void)yyg;
-
 	/* The cast to (char *) in the following accommodates both
 	 * implementations that use char* generic pointers, and those
 	 * that use void* generic pointers.  It works with the latter
@@ -2384,23 +2298,20 @@ void *yyrealloc  (void * ptr, yy_size_t  size , yyscan_t yyscanner)
 	 * any pointer type to void*, and deal with argument conversions
 	 * as though doing an assignment.
 	 */
-	return realloc(ptr, size);
+	return (void *) realloc( (char *) ptr, size );
 }
 
 void yyfree (void * ptr , yyscan_t yyscanner)
 {
-	struct yyguts_t * yyg = (struct yyguts_t*)yyscanner;
-	(void)yyg;
 	free( (char *) ptr );	/* see yyrealloc() for (char *) cast */
 }
 
 #define YYTABLES_NAME "yytables"
 
-#line 90 "lex_sql.l"
+#line 88 "lex_sql.l"
+
 
 
 void scan_string(const char *str, yyscan_t scanner) {
-	yy_switch_to_buffer(yy_scan_string(str, scanner), scanner);
+	yy_switch_to_buffer(yy_scan_string(str,scanner),scanner);
 }
-
-
diff --git a/src/observer/sql/parser/lex_sql.l b/src/observer/sql/parser/lex_sql.l
index de1347a..916650e 100644
--- a/src/observer/sql/parser/lex_sql.l
+++ b/src/observer/sql/parser/lex_sql.l
@@ -29,6 +29,7 @@ ID               [A-Za-z_]+[A-Za-z0-9_]*
 DOT              \.
 QUOTE            [\'\"]
 POZ              \-
+
 %x STR
 
 %%
@@ -92,4 +93,40 @@ POZ              \-
 void scan_string(const char *str, yyscan_t scanner) {
 	yy_switch_to_buffer(yy_scan_string(str, scanner), scanner);
 }
-
+/*By:CAQ
+* 用于将字符串转为年月日的int型，传入str_date中
+* 不进行日期的合法性校验
+*/
+void str2date(const char *str,int * int_date){
+       int i;
+       int total=0,get = 0;
+  int year,month,datetime;
+       for(i=0;str[i]!='\0';i++){
+               if(str[i]!='-'){
+                       total *=10;
+                       total += str[i]+0-'0';
+                       //printf("%d\n",total);
+               }
+               else{
+                       if(get==0){
+                               year= total;
+                       }
+                       else if(get==1){
+                               month = total;
+                       }
+                       total = 0;
+                       get++;
+               }
+       }
+       datetime = total;
+  *int_date = year*10000+month*100+datetime;
+       return ;
+}
+/*By:CAQ*/
+void value_init_date(Value *value, const char *v){
+  LOG_INFO("This is a Date!:%s\n",v);
+  value->type = DATES;
+  value->data = malloc(sizeof(int));
+  str2date(v,(int *)(value -> data));
+  LOG_INFO("The Date storage is :%d\n",*(int *)(value->data));
+}
diff --git a/src/observer/sql/parser/parse.cpp b/src/observer/sql/parser/parse.cpp
index 396507c..25d2293 100644
--- a/src/observer/sql/parser/parse.cpp
+++ b/src/observer/sql/parser/parse.cpp
@@ -50,48 +50,8 @@ void value_init_float(Value *value, float v) {
 }
 void value_init_string(Value *value, const char *v) {
   value->type = CHARS;
-  LOG_INFO("This is a String!:%s\n",v);
   value->data = strdup(v);
 }
-
-/*By:CAQ
-* 用于将字符串转为年月日的int型，传入str_date中
-* 不进行日期的合法性校验
-*/
-void str2date(const char *str,int * int_date){
-	int i;
-	int total=0,get = 0;
-  int year,month,datetime;
-	for(i=0;str[i]!='\0';i++){
-		if(str[i]!='-'){
-			total *=10;
-			total += str[i]+0-'0';
-			//printf("%d\n",total);
-		}
-		else{
-			if(get==0){
-				year= total;
-			}
-			else if(get==1){
-				month = total;
-			}
-			total = 0;
-			get++;
-		}
-	}
-	datetime = total;
-  *int_date = year*10000+month*100+datetime;
-	return ;
-}
-/*By:CAQ*/
-void value_init_date(Value *value, const char *v){
-  LOG_INFO("This is a Date!:%s\n",v);
-  value->type = DATES;
-  value->data = malloc(sizeof(int));
-  str2date(v,(int *)(value -> data));
-  LOG_INFO("The Date storage is :%d\n",*(int *)(value->data));
-}
-
 void value_destroy(Value *value) {
   value->type = UNDEFINED;
   free(value->data);
@@ -409,8 +369,6 @@ RC parse(const char *st, Query *sqln) {
 
   if (sqln->flag == SCF_ERROR)
     return SQL_SYNTAX;
-  else if(sqln->flag == SCF_DERROR)
-    return INVALID_ARGUMENT;
   else
     return SUCCESS;
 }
\ No newline at end of file
diff --git a/src/observer/sql/parser/parse_defs.h b/src/observer/sql/parser/parse_defs.h
index 424a82c..110b49c 100644
--- a/src/observer/sql/parser/parse_defs.h
+++ b/src/observer/sql/parser/parse_defs.h
@@ -16,7 +16,7 @@ See the Mulan PSL v2 for more details. */
 #define __OBSERVER_SQL_PARSER_PARSE_DEFS_H__
 
 #include <stddef.h>
-#include <string.h>
+
 #define MAX_NUM 20
 #define MAX_REL_NAME 20
 #define MAX_ATTR_NAME 20
@@ -165,8 +165,7 @@ enum SqlCommandFlag {
   SCF_ROLLBACK,
   SCF_LOAD_DATA,
   SCF_HELP,
-  SCF_EXIT,
-  SCF_DERROR
+  SCF_EXIT
 };
 // struct of flag and sql_struct
 typedef struct Query {
@@ -183,8 +182,8 @@ void relation_attr_destroy(RelAttr *relation_attr);
 
 void value_init_integer(Value *value, int v);
 void value_init_float(Value *value, float v);
-void value_init_date(Value *value, const char *v);
 void value_init_string(Value *value, const char *v);
+void value_init_date(Value *value, const char *v);
 void value_destroy(Value *value);
 
 void condition_init(Condition *condition, CompOp comp, int left_is_attr, RelAttr *left_attr, Value *left_value,
diff --git a/src/observer/sql/parser/parse_stage.cpp b/src/observer/sql/parser/parse_stage.cpp
index a901d16..57c3a94 100644
--- a/src/observer/sql/parser/parse_stage.cpp
+++ b/src/observer/sql/parser/parse_stage.cpp
@@ -124,10 +124,7 @@ StageEvent *ParseStage::handle_request(StageEvent *event) {
     // set error information to event
     const char *error = result->sstr.errors != nullptr ? result->sstr.errors : "Unknown error";
     char response[256];
-    if(ret == RC::SQL_SYNTAX)
-      snprintf(response, sizeof(response), "Failed to parse sql: %s, error msg: %s\n", sql.c_str(), error);
-    else if(ret == RC::INVALID_ARGUMENT)
-      snprintf(response, sizeof(response),"Failure");
+    snprintf(response, sizeof(response), "Failed to parse sql: %s, error msg: %s\n", sql.c_str(), error);
     sql_event->session_event()->set_response(response);
     query_destroy(result);
     return nullptr;
diff --git a/src/observer/sql/parser/yacc_sql.tab.c b/src/observer/sql/parser/yacc_sql.tab.c
index 68612c0..2f8855d 100644
--- a/src/observer/sql/parser/yacc_sql.tab.c
+++ b/src/observer/sql/parser/yacc_sql.tab.c
@@ -1,4 +1,4 @@
-/* A Bison parser, made by GNU Bison 3.5.1.  */
+/* A Bison parser, made by GNU Bison 3.7.  */
 
 /* Bison implementation for Yacc-like parsers in C
 
@@ -34,6 +34,10 @@
 /* C LALR(1) parser skeleton written by Richard Stallman, by
    simplifying the original so-called "semantic" parser.  */
 
+/* DO NOT RELY ON FEATURES THAT ARE NOT DOCUMENTED in the manual,
+   especially those whose name start with YY_ or yy_.  They are
+   private implementation details that can be changed or removed.  */
+
 /* All symbols defined below should begin with yy or YY, to avoid
    infringing on user name space.  This should be done even for local
    variables, as they might otherwise be expanded by user macros.
@@ -41,14 +45,11 @@
    define necessary library symbols; they are noted "INFRINGES ON
    USER NAME SPACE" below.  */
 
-/* Undocumented macros, especially those whose name start with YY_,
-   are private implementation details.  Do not rely on them.  */
-
 /* Identify Bison output.  */
 #define YYBISON 1
 
 /* Bison version.  */
-#define YYBISON_VERSION "3.5.1"
+#define YYBISON_VERSION "3.7"
 
 /* Skeleton name.  */
 #define YYSKELETON_NAME "yacc.c"
@@ -72,7 +73,7 @@
 #include "sql/parser/parse_defs.h"
 #include "sql/parser/yacc_sql.tab.h"
 #include "sql/parser/lex.yy.h"
-//#include "common/log/log.h" // 包含C++中的头文件
+// #include "common/log/log.h" // 包含C++中的头文件
 
 #include<stdio.h>
 #include<stdlib.h>
@@ -114,17 +115,6 @@ void yyerror(yyscan_t scanner, const char *str)
   context->ssql->sstr.insertion.value_num = 0;
   printf("parse sql failed. error=%s", str);
 }
-void yyerror_date(yyscan_t scanner)
-{
-  ParserContext *context = (ParserContext *)(yyget_extra(scanner));
-  query_reset(context->ssql);
-  context->ssql->flag = SCF_DERROR;
-  context->condition_length = 0;
-  context->from_length = 0;
-  context->select_length = 0;
-  context->value_length = 0;
-  context->ssql->sstr.insertion.value_num = 0;
-}
 
 ParserContext *get_context(yyscan_t scanner)
 {
@@ -134,7 +124,7 @@ ParserContext *get_context(yyscan_t scanner)
 #define CONTEXT get_context(scanner)
 
 
-#line 138 "yacc_sql.tab.c"
+#line 128 "yacc_sql.tab.c"
 
 # ifndef YY_CAST
 #  ifdef __cplusplus
@@ -157,112 +147,99 @@ ParserContext *get_context(yyscan_t scanner)
 #  endif
 # endif
 
-/* Enabling verbose error messages.  */
-#ifdef YYERROR_VERBOSE
-# undef YYERROR_VERBOSE
-# define YYERROR_VERBOSE 1
-#else
-# define YYERROR_VERBOSE 0
-#endif
-
-/* Use api.header.include to #include this header
-   instead of duplicating it here.  */
-#ifndef YY_YY_YACC_SQL_TAB_H_INCLUDED
-# define YY_YY_YACC_SQL_TAB_H_INCLUDED
-/* Debug traces.  */
-#ifndef YYDEBUG
-# define YYDEBUG 0
-#endif
-#if YYDEBUG
-extern int yydebug;
-#endif
-
-/* Token type.  */
-#ifndef YYTOKENTYPE
-# define YYTOKENTYPE
-  enum yytokentype
-  {
-    SEMICOLON = 258,
-    CREATE = 259,
-    DROP = 260,
-    TABLE = 261,
-    TABLES = 262,
-    INDEX = 263,
-    SELECT = 264,
-    DESC = 265,
-    SHOW = 266,
-    SYNC = 267,
-    INSERT = 268,
-    DELETE = 269,
-    UPDATE = 270,
-    LBRACE = 271,
-    RBRACE = 272,
-    COMMA = 273,
-    TRX_BEGIN = 274,
-    TRX_COMMIT = 275,
-    TRX_ROLLBACK = 276,
-    INT_T = 277,
-    STRING_T = 278,
-    FLOAT_T = 279,
-    DATE_T = 280,
-    HELP = 281,
-    EXIT = 282,
-    DOT = 283,
-    INTO = 284,
-    VALUES = 285,
-    FROM = 286,
-    WHERE = 287,
-    AND = 288,
-    SET = 289,
-    ON = 290,
-    LOAD = 291,
-    DATA = 292,
-    INFILE = 293,
-    EQ = 294,
-    LT = 295,
-    GT = 296,
-    LE = 297,
-    GE = 298,
-    NE = 299,
-    NUMBER = 300,
-    FLOAT = 301,
-    ID = 302,
-    PATH = 303,
-    SSS = 304,
-    STAR = 305,
-    DATE = 306,
-    STRING_V = 307
-  };
-#endif
-
-/* Value type.  */
-#if ! defined YYSTYPE && ! defined YYSTYPE_IS_DECLARED
-union YYSTYPE
+#include "yacc_sql.tab.h"
+/* Symbol kind.  */
+enum yysymbol_kind_t
 {
-#line 118 "yacc_sql.y"
-
-  struct _Attr *attr;
-  struct _Condition *condition1;
-  struct _Value *value1;
-  char *datestr;
-  char *string;
-  int number;
-  float floats;
-	char *position;
-
-#line 254 "yacc_sql.tab.c"
-
+  YYSYMBOL_YYEMPTY = -2,
+  YYSYMBOL_YYEOF = 0,                      /* "end of file"  */
+  YYSYMBOL_YYerror = 1,                    /* error  */
+  YYSYMBOL_YYUNDEF = 2,                    /* "invalid token"  */
+  YYSYMBOL_SEMICOLON = 3,                  /* SEMICOLON  */
+  YYSYMBOL_CREATE = 4,                     /* CREATE  */
+  YYSYMBOL_DROP = 5,                       /* DROP  */
+  YYSYMBOL_TABLE = 6,                      /* TABLE  */
+  YYSYMBOL_TABLES = 7,                     /* TABLES  */
+  YYSYMBOL_INDEX = 8,                      /* INDEX  */
+  YYSYMBOL_SELECT = 9,                     /* SELECT  */
+  YYSYMBOL_DESC = 10,                      /* DESC  */
+  YYSYMBOL_SHOW = 11,                      /* SHOW  */
+  YYSYMBOL_SYNC = 12,                      /* SYNC  */
+  YYSYMBOL_INSERT = 13,                    /* INSERT  */
+  YYSYMBOL_DELETE = 14,                    /* DELETE  */
+  YYSYMBOL_UPDATE = 15,                    /* UPDATE  */
+  YYSYMBOL_LBRACE = 16,                    /* LBRACE  */
+  YYSYMBOL_RBRACE = 17,                    /* RBRACE  */
+  YYSYMBOL_COMMA = 18,                     /* COMMA  */
+  YYSYMBOL_TRX_BEGIN = 19,                 /* TRX_BEGIN  */
+  YYSYMBOL_TRX_COMMIT = 20,                /* TRX_COMMIT  */
+  YYSYMBOL_TRX_ROLLBACK = 21,              /* TRX_ROLLBACK  */
+  YYSYMBOL_INT_T = 22,                     /* INT_T  */
+  YYSYMBOL_STRING_T = 23,                  /* STRING_T  */
+  YYSYMBOL_FLOAT_T = 24,                   /* FLOAT_T  */
+  YYSYMBOL_HELP = 25,                      /* HELP  */
+  YYSYMBOL_EXIT = 26,                      /* EXIT  */
+  YYSYMBOL_DOT = 27,                       /* DOT  */
+  YYSYMBOL_INTO = 28,                      /* INTO  */
+  YYSYMBOL_VALUES = 29,                    /* VALUES  */
+  YYSYMBOL_FROM = 30,                      /* FROM  */
+  YYSYMBOL_WHERE = 31,                     /* WHERE  */
+  YYSYMBOL_AND = 32,                       /* AND  */
+  YYSYMBOL_SET = 33,                       /* SET  */
+  YYSYMBOL_ON = 34,                        /* ON  */
+  YYSYMBOL_LOAD = 35,                      /* LOAD  */
+  YYSYMBOL_DATA = 36,                      /* DATA  */
+  YYSYMBOL_INFILE = 37,                    /* INFILE  */
+  YYSYMBOL_EQ = 38,                        /* EQ  */
+  YYSYMBOL_LT = 39,                        /* LT  */
+  YYSYMBOL_GT = 40,                        /* GT  */
+  YYSYMBOL_LE = 41,                        /* LE  */
+  YYSYMBOL_GE = 42,                        /* GE  */
+  YYSYMBOL_NE = 43,                        /* NE  */
+  YYSYMBOL_NUMBER = 44,                    /* NUMBER  */
+  YYSYMBOL_FLOAT = 45,                     /* FLOAT  */
+  YYSYMBOL_ID = 46,                        /* ID  */
+  YYSYMBOL_PATH = 47,                      /* PATH  */
+  YYSYMBOL_SSS = 48,                       /* SSS  */
+  YYSYMBOL_STAR = 49,                      /* STAR  */
+  YYSYMBOL_STRING_V = 50,                  /* STRING_V  */
+  YYSYMBOL_YYACCEPT = 51,                  /* $accept  */
+  YYSYMBOL_commands = 52,                  /* commands  */
+  YYSYMBOL_command = 53,                   /* command  */
+  YYSYMBOL_exit = 54,                      /* exit  */
+  YYSYMBOL_help = 55,                      /* help  */
+  YYSYMBOL_sync = 56,                      /* sync  */
+  YYSYMBOL_begin = 57,                     /* begin  */
+  YYSYMBOL_commit = 58,                    /* commit  */
+  YYSYMBOL_rollback = 59,                  /* rollback  */
+  YYSYMBOL_drop_table = 60,                /* drop_table  */
+  YYSYMBOL_show_tables = 61,               /* show_tables  */
+  YYSYMBOL_desc_table = 62,                /* desc_table  */
+  YYSYMBOL_create_index = 63,              /* create_index  */
+  YYSYMBOL_drop_index = 64,                /* drop_index  */
+  YYSYMBOL_create_table = 65,              /* create_table  */
+  YYSYMBOL_attr_def_list = 66,             /* attr_def_list  */
+  YYSYMBOL_attr_def = 67,                  /* attr_def  */
+  YYSYMBOL_number = 68,                    /* number  */
+  YYSYMBOL_type = 69,                      /* type  */
+  YYSYMBOL_ID_get = 70,                    /* ID_get  */
+  YYSYMBOL_insert = 71,                    /* insert  */
+  YYSYMBOL_value_list = 72,                /* value_list  */
+  YYSYMBOL_value = 73,                     /* value  */
+  YYSYMBOL_delete = 74,                    /* delete  */
+  YYSYMBOL_update = 75,                    /* update  */
+  YYSYMBOL_select = 76,                    /* select  */
+  YYSYMBOL_select_attr = 77,               /* select_attr  */
+  YYSYMBOL_attr_list = 78,                 /* attr_list  */
+  YYSYMBOL_rel_list = 79,                  /* rel_list  */
+  YYSYMBOL_where = 80,                     /* where  */
+  YYSYMBOL_condition_list = 81,            /* condition_list  */
+  YYSYMBOL_condition = 82,                 /* condition  */
+  YYSYMBOL_comOp = 83,                     /* comOp  */
+  YYSYMBOL_load_data = 84                  /* load_data  */
 };
-typedef union YYSTYPE YYSTYPE;
-# define YYSTYPE_IS_TRIVIAL 1
-# define YYSTYPE_IS_DECLARED 1
-#endif
-
-
+typedef enum yysymbol_kind_t yysymbol_kind_t;
 
-int yyparse (void *scanner);
-
-#endif /* !YY_YY_YACC_SQL_TAB_H_INCLUDED  */
 
 
 
@@ -362,6 +339,7 @@ typedef int yytype_uint16;
 
 #define YYSIZEOF(X) YY_CAST (YYPTRDIFF_T, sizeof (X))
 
+
 /* Stored state numbers (used for stacks). */
 typedef yytype_uint8 yy_state_t;
 
@@ -380,6 +358,7 @@ typedef int yy_state_fast_t;
 # endif
 #endif
 
+
 #ifndef YY_ATTRIBUTE_PURE
 # if defined __GNUC__ && 2 < __GNUC__ + (96 <= __GNUC_MINOR__)
 #  define YY_ATTRIBUTE_PURE __attribute__ ((__pure__))
@@ -437,7 +416,7 @@ typedef int yy_state_fast_t;
 
 #define YY_ASSERT(E) ((void) (0 && (E)))
 
-#if ! defined yyoverflow || YYERROR_VERBOSE
+#if !defined yyoverflow
 
 /* The parser invokes alloca or malloc; define the necessary symbols.  */
 
@@ -502,8 +481,7 @@ void free (void *); /* INFRINGES ON USER NAME SPACE */
 #   endif
 #  endif
 # endif
-#endif /* ! defined yyoverflow || YYERROR_VERBOSE */
-
+#endif /* !defined yyoverflow */
 
 #if (! defined yyoverflow \
      && (! defined __cplusplus \
@@ -568,25 +546,27 @@ union yyalloc
 /* YYFINAL -- State number of the termination state.  */
 #define YYFINAL  2
 /* YYLAST -- Last index in YYTABLE.  */
-#define YYLAST   154
+#define YYLAST   148
 
 /* YYNTOKENS -- Number of terminals.  */
-#define YYNTOKENS  53
+#define YYNTOKENS  51
 /* YYNNTS -- Number of nonterminals.  */
 #define YYNNTS  34
 /* YYNRULES -- Number of rules.  */
-#define YYNRULES  78
+#define YYNRULES  76
 /* YYNSTATES -- Number of states.  */
-#define YYNSTATES  164
+#define YYNSTATES  162
 
-#define YYUNDEFTOK  2
-#define YYMAXUTOK   307
+/* YYMAXUTOK -- Last valid token kind.  */
+#define YYMAXUTOK   305
 
 
 /* YYTRANSLATE(TOKEN-NUM) -- Symbol number corresponding to TOKEN-NUM
    as returned by yylex, with out-of-bounds checking.  */
-#define YYTRANSLATE(YYX)                                                \
-  (0 <= (YYX) && (YYX) <= YYMAXUTOK ? yytranslate[YYX] : YYUNDEFTOK)
+#define YYTRANSLATE(YYX)                                \
+  (0 <= (YYX) && (YYX) <= YYMAXUTOK                     \
+   ? YY_CAST (yysymbol_kind_t, yytranslate[YYX])        \
+   : YYSYMBOL_YYUNDEF)
 
 /* YYTRANSLATE[TOKEN-NUM] -- Symbol number corresponding to TOKEN-NUM
    as returned by yylex.  */
@@ -622,36 +602,43 @@ static const yytype_int8 yytranslate[] =
       15,    16,    17,    18,    19,    20,    21,    22,    23,    24,
       25,    26,    27,    28,    29,    30,    31,    32,    33,    34,
       35,    36,    37,    38,    39,    40,    41,    42,    43,    44,
-      45,    46,    47,    48,    49,    50,    51,    52
+      45,    46,    47,    48,    49,    50
 };
 
 #if YYDEBUG
   /* YYRLINE[YYN] -- Source line where rule number YYN was defined.  */
 static const yytype_int16 yyrline[] =
 {
-       0,   146,   146,   148,   152,   153,   154,   155,   156,   157,
-     158,   159,   160,   161,   162,   163,   164,   165,   166,   167,
-     168,   172,   177,   182,   188,   194,   200,   206,   212,   218,
-     225,   233,   240,   249,   251,   255,   266,   279,   282,   283,
-     284,   285,   288,   297,   313,   315,   320,   323,   326,   332,
-     339,   349,   359,   378,   383,   388,   394,   396,   403,   412,
-     414,   418,   420,   424,   426,   431,   452,   472,   492,   514,
-     535,   556,   578,   579,   580,   581,   582,   583,   587
+       0,   132,   132,   134,   138,   139,   140,   141,   142,   143,
+     144,   145,   146,   147,   148,   149,   150,   151,   152,   153,
+     154,   158,   163,   168,   174,   180,   186,   192,   198,   204,
+     211,   219,   226,   235,   237,   241,   252,   265,   268,   269,
+     270,   273,   282,   298,   300,   305,   308,   311,   318,   328,
+     338,   357,   362,   367,   373,   375,   382,   391,   393,   397,
+     399,   403,   405,   410,   431,   451,   471,   493,   514,   535,
+     557,   558,   559,   560,   561,   562,   566
 };
 #endif
 
-#if YYDEBUG || YYERROR_VERBOSE || 0
+/** Accessing symbol of state STATE.  */
+#define YY_ACCESSING_SYMBOL(State) YY_CAST (yysymbol_kind_t, yystos[State])
+
+#if YYDEBUG || 0
+/* The user-facing name of the symbol whose (internal) number is
+   YYSYMBOL.  No bounds checking.  */
+static const char *yysymbol_name (yysymbol_kind_t yysymbol) YY_ATTRIBUTE_UNUSED;
+
 /* YYTNAME[SYMBOL-NUM] -- String name of the symbol SYMBOL-NUM.
    First, the terminals, then, starting at YYNTOKENS, nonterminals.  */
 static const char *const yytname[] =
 {
-  "$end", "error", "$undefined", "SEMICOLON", "CREATE", "DROP", "TABLE",
-  "TABLES", "INDEX", "SELECT", "DESC", "SHOW", "SYNC", "INSERT", "DELETE",
-  "UPDATE", "LBRACE", "RBRACE", "COMMA", "TRX_BEGIN", "TRX_COMMIT",
-  "TRX_ROLLBACK", "INT_T", "STRING_T", "FLOAT_T", "DATE_T", "HELP", "EXIT",
-  "DOT", "INTO", "VALUES", "FROM", "WHERE", "AND", "SET", "ON", "LOAD",
-  "DATA", "INFILE", "EQ", "LT", "GT", "LE", "GE", "NE", "NUMBER", "FLOAT",
-  "ID", "PATH", "SSS", "STAR", "DATE", "STRING_V", "$accept", "commands",
+  "\"end of file\"", "error", "\"invalid token\"", "SEMICOLON", "CREATE",
+  "DROP", "TABLE", "TABLES", "INDEX", "SELECT", "DESC", "SHOW", "SYNC",
+  "INSERT", "DELETE", "UPDATE", "LBRACE", "RBRACE", "COMMA", "TRX_BEGIN",
+  "TRX_COMMIT", "TRX_ROLLBACK", "INT_T", "STRING_T", "FLOAT_T", "HELP",
+  "EXIT", "DOT", "INTO", "VALUES", "FROM", "WHERE", "AND", "SET", "ON",
+  "LOAD", "DATA", "INFILE", "EQ", "LT", "GT", "LE", "GE", "NE", "NUMBER",
+  "FLOAT", "ID", "PATH", "SSS", "STAR", "STRING_V", "$accept", "commands",
   "command", "exit", "help", "sync", "begin", "commit", "rollback",
   "drop_table", "show_tables", "desc_table", "create_index", "drop_index",
   "create_table", "attr_def_list", "attr_def", "number", "type", "ID_get",
@@ -659,9 +646,15 @@ static const char *const yytname[] =
   "select_attr", "attr_list", "rel_list", "where", "condition_list",
   "condition", "comOp", "load_data", YY_NULLPTR
 };
+
+static const char *
+yysymbol_name (yysymbol_kind_t yysymbol)
+{
+  return yytname[yysymbol];
+}
 #endif
 
-# ifdef YYPRINT
+#ifdef YYPRINT
 /* YYTOKNUM[NUM] -- (External) token number corresponding to the
    (internal) symbol number NUM (which must be that of a token).  */
 static const yytype_int16 yytoknum[] =
@@ -671,11 +664,11 @@ static const yytype_int16 yytoknum[] =
      275,   276,   277,   278,   279,   280,   281,   282,   283,   284,
      285,   286,   287,   288,   289,   290,   291,   292,   293,   294,
      295,   296,   297,   298,   299,   300,   301,   302,   303,   304,
-     305,   306,   307
+     305
 };
-# endif
+#endif
 
-#define YYPACT_NINF (-96)
+#define YYPACT_NINF (-95)
 
 #define yypact_value_is_default(Yyn) \
   ((Yyn) == YYPACT_NINF)
@@ -689,23 +682,23 @@ static const yytype_int16 yytoknum[] =
      STATE-NUM.  */
 static const yytype_int16 yypact[] =
 {
-     -96,     2,   -96,    19,    36,   -14,   -42,    12,    17,    -3,
-       1,    -6,    34,    49,    53,    55,    61,    29,   -96,   -96,
-     -96,   -96,   -96,   -96,   -96,   -96,   -96,   -96,   -96,   -96,
-     -96,   -96,   -96,   -96,   -96,   -96,    24,    26,    31,    33,
-     -10,   -96,    54,    81,    84,   -96,    52,    56,    66,   -96,
-     -96,   -96,   -96,   -96,    63,    86,    69,   102,   103,    60,
-      62,   -96,    64,   -96,   -96,    78,    80,    67,    68,    71,
-      72,   -96,   -96,     6,    92,    95,    99,     8,   113,    82,
-      91,   -96,   104,    73,   107,    77,   -96,   -96,    79,    80,
-      37,   -96,   -96,     7,   -96,   -96,    50,    94,   -96,    37,
-     119,    71,   111,   -96,   -96,   -96,   -96,   114,    85,    92,
-      95,   126,   115,    87,   -96,   -96,   -96,   -96,   -96,   -96,
-      16,    23,     8,   -96,    80,    88,   104,   128,    93,   120,
-     -96,   -96,   -96,    37,   122,    50,   -96,   -96,   108,   -96,
-      94,   137,   138,   -96,   -96,   -96,   125,   140,   115,   141,
-      30,    98,   -96,   -96,   -96,   -96,   -96,   -96,   -96,   118,
-     -96,   -96,   100,   -96
+     -95,     5,   -95,    78,    79,    31,   -40,     0,     8,    -1,
+      -7,   -14,    39,    40,    53,    54,    64,    26,   -95,   -95,
+     -95,   -95,   -95,   -95,   -95,   -95,   -95,   -95,   -95,   -95,
+     -95,   -95,   -95,   -95,   -95,   -95,    33,    42,    43,    44,
+      -6,   -95,    61,    69,    89,   -95,    47,    48,    62,   -95,
+     -95,   -95,   -95,   -95,    60,    80,    65,    95,    97,    55,
+      56,   -95,    57,   -95,   -95,    75,    74,    63,    58,    66,
+      67,   -95,   -95,    -5,    90,    92,    91,    15,   108,    76,
+      87,   -95,    98,    59,   101,    72,   -95,   -95,    73,    74,
+     -10,   -95,   -95,     6,   -95,    12,    88,   -95,   -10,   115,
+      66,   105,   -95,   -95,   -95,   107,    81,    90,    92,   121,
+     110,    83,   -95,   -95,   -95,   -95,   -95,   -95,    20,    25,
+      15,   -95,    74,    84,    98,   122,    82,   114,   -95,   -95,
+     -95,   -10,   116,    12,   -95,   -95,   109,   -95,    88,   129,
+     131,   -95,   -95,   -95,   118,   134,   110,   135,    30,    93,
+     -95,   -95,   -95,   -95,   -95,   -95,   -95,   113,   -95,   -95,
+      96,   -95
 };
 
   /* YYDEFACT[STATE-NUM] -- Default reduction number in state STATE-NUM.
@@ -717,37 +710,37 @@ static const yytype_int8 yydefact[] =
        0,     0,     0,     0,     0,     0,     0,     0,     3,    20,
       19,    14,    15,    16,    17,     9,    10,    11,    12,    13,
        8,     5,     7,     6,     4,    18,     0,     0,     0,     0,
-      56,    53,     0,     0,     0,    23,     0,     0,     0,    24,
+      54,    51,     0,     0,     0,    23,     0,     0,     0,    24,
       25,    26,    22,    21,     0,     0,     0,     0,     0,     0,
-       0,    54,     0,    29,    28,     0,    61,     0,     0,     0,
-       0,    27,    31,    56,    56,    59,     0,     0,     0,     0,
-       0,    42,    33,     0,     0,     0,    57,    55,     0,    61,
-       0,    46,    47,     0,    49,    48,     0,    63,    50,     0,
-       0,     0,     0,    38,    39,    40,    41,    36,     0,    56,
-      59,     0,    44,     0,    72,    73,    74,    75,    76,    77,
-       0,     0,     0,    62,    61,     0,    33,     0,     0,     0,
-      58,    60,    52,     0,     0,     0,    67,    65,    68,    66,
-      63,     0,     0,    34,    32,    37,     0,     0,    44,     0,
-       0,     0,    64,    51,    78,    35,    30,    45,    43,     0,
-      69,    70,     0,    71
+       0,    52,     0,    29,    28,     0,    59,     0,     0,     0,
+       0,    27,    31,    54,    54,    57,     0,     0,     0,     0,
+       0,    41,    33,     0,     0,     0,    55,    53,     0,    59,
+       0,    45,    46,     0,    47,     0,    61,    48,     0,     0,
+       0,     0,    38,    39,    40,    36,     0,    54,    57,     0,
+      43,     0,    70,    71,    72,    73,    74,    75,     0,     0,
+       0,    60,    59,     0,    33,     0,     0,     0,    56,    58,
+      50,     0,     0,     0,    65,    63,    66,    64,    61,     0,
+       0,    34,    32,    37,     0,     0,    43,     0,     0,     0,
+      62,    49,    76,    35,    30,    44,    42,     0,    67,    68,
+       0,    69
 };
 
   /* YYPGOTO[NTERM-NUM].  */
 static const yytype_int8 yypgoto[] =
 {
-     -96,   -96,   -96,   -96,   -96,   -96,   -96,   -96,   -96,   -96,
-     -96,   -96,   -96,   -96,   -96,    22,    48,   -96,   -96,   -96,
-     -96,     3,   -90,   -96,   -96,   -96,   -96,   -70,    40,   -79,
-      13,    32,   -95,   -96
+     -95,   -95,   -95,   -95,   -95,   -95,   -95,   -95,   -95,   -95,
+     -95,   -95,   -95,   -95,   -95,    17,    45,   -95,   -95,   -95,
+     -95,    -3,   -90,   -95,   -95,   -95,   -95,   -71,    36,   -85,
+       9,    28,   -94,   -95
 };
 
   /* YYDEFGOTO[NTERM-NUM].  */
 static const yytype_int16 yydefgoto[] =
 {
       -1,     1,    18,    19,    20,    21,    22,    23,    24,    25,
-      26,    27,    28,    29,    30,   102,    82,   146,   107,    83,
-      31,   134,    96,    32,    33,    34,    42,    61,    89,    78,
-     123,    97,   120,    35
+      26,    27,    28,    29,    30,   101,    82,   144,   105,    83,
+      31,   132,    95,    32,    33,    34,    42,    61,    89,    78,
+     121,    96,   118,    35
 };
 
   /* YYTABLE[YYPACT[STATE-NUM]] -- What to do in state STATE-NUM.  If
@@ -755,78 +748,76 @@ static const yytype_int16 yydefgoto[] =
      number is the opposite.  If YYTABLE_NINF, syntax error.  */
 static const yytype_uint8 yytable[] =
 {
-     112,   121,     2,    86,    87,    43,     3,     4,    59,   124,
-     111,     5,     6,     7,     8,     9,    10,    11,    60,    44,
-      45,    12,    13,    14,    59,    36,    46,    37,    15,    16,
-     137,   139,    47,    40,    85,   113,    41,    49,    17,   130,
-     150,    48,    38,   148,    39,   141,   114,   115,   116,   117,
-     118,   119,    50,    91,    92,    93,    51,    94,    52,    95,
-     160,    91,    92,   136,    53,    94,    54,    95,    91,    92,
-     138,    55,    94,    56,    95,    91,    92,   159,    57,    94,
-      58,    95,    91,    92,    63,    62,    94,    64,    95,   114,
-     115,   116,   117,   118,   119,   103,   104,   105,   106,    65,
-      67,    68,    69,    66,    70,    71,    72,    73,    76,    74,
-      59,    75,    77,    88,    79,    90,    98,    80,    81,    84,
-     100,    99,   101,   108,   109,   125,   110,   122,   127,   132,
-     128,   144,   129,   133,   135,   142,   151,   147,   145,   149,
-     153,   154,   155,   156,   158,   161,   162,   163,   143,   126,
-     131,   157,     0,   152,   140
+     110,   119,    86,    87,   109,     2,    43,    44,   122,     3,
+       4,    45,    59,    59,     5,     6,     7,     8,     9,    10,
+      11,    60,    85,    47,    12,    13,    14,    46,   135,   137,
+      15,    16,    48,   111,    91,    92,   128,   139,    94,   148,
+      17,   146,    49,    50,   112,   113,   114,   115,   116,   117,
+     112,   113,   114,   115,   116,   117,    51,    52,   158,    91,
+      92,    93,    54,    94,    91,    92,   134,    53,    94,    91,
+      92,   136,    63,    94,    91,    92,   157,    40,    94,    55,
+      41,   102,   103,   104,    36,    38,    37,    39,    56,    57,
+      58,    62,    64,    65,    66,    67,    69,    68,    71,    70,
+      72,    73,    74,    75,    76,    77,    80,    90,    59,    79,
+      88,    97,    81,    84,    98,    99,   100,   106,   107,   108,
+     120,   123,   125,   126,   130,   142,   143,   127,   131,   133,
+     140,   145,   151,   147,   152,   153,   149,   154,   156,   159,
+     160,   141,   161,   155,   129,   124,     0,   150,   138
 };
 
 static const yytype_int16 yycheck[] =
 {
-      90,    96,     0,    73,    74,    47,     4,     5,    18,    99,
-      89,     9,    10,    11,    12,    13,    14,    15,    28,     7,
-       3,    19,    20,    21,    18,     6,    29,     8,    26,    27,
-     120,   121,    31,    47,    28,    28,    50,     3,    36,   109,
-     135,    47,     6,   133,     8,   124,    39,    40,    41,    42,
-      43,    44,     3,    45,    46,    47,     3,    49,     3,    51,
-     150,    45,    46,    47,     3,    49,    37,    51,    45,    46,
-      47,    47,    49,    47,    51,    45,    46,    47,    47,    49,
-      47,    51,    45,    46,     3,    31,    49,     3,    51,    39,
-      40,    41,    42,    43,    44,    22,    23,    24,    25,    47,
-      34,    38,    16,    47,    35,     3,     3,    47,    30,    47,
-      18,    47,    32,    18,    47,    16,     3,    49,    47,    47,
-      29,    39,    18,    16,    47,     6,    47,    33,    17,     3,
-      16,     3,    47,    18,    47,    47,    28,    17,    45,    17,
-       3,     3,    17,     3,     3,    47,    28,    47,   126,   101,
-     110,   148,    -1,   140,   122
+      90,    95,    73,    74,    89,     0,    46,     7,    98,     4,
+       5,     3,    18,    18,     9,    10,    11,    12,    13,    14,
+      15,    27,    27,    30,    19,    20,    21,    28,   118,   119,
+      25,    26,    46,    27,    44,    45,   107,   122,    48,   133,
+      35,   131,     3,     3,    38,    39,    40,    41,    42,    43,
+      38,    39,    40,    41,    42,    43,     3,     3,   148,    44,
+      45,    46,    36,    48,    44,    45,    46,     3,    48,    44,
+      45,    46,     3,    48,    44,    45,    46,    46,    48,    46,
+      49,    22,    23,    24,     6,     6,     8,     8,    46,    46,
+      46,    30,     3,    46,    46,    33,    16,    37,     3,    34,
+       3,    46,    46,    46,    29,    31,    48,    16,    18,    46,
+      18,     3,    46,    46,    38,    28,    18,    16,    46,    46,
+      32,     6,    17,    16,     3,     3,    44,    46,    18,    46,
+      46,    17,     3,    17,     3,    17,    27,     3,     3,    46,
+      27,   124,    46,   146,   108,   100,    -1,   138,   120
 };
 
   /* YYSTOS[STATE-NUM] -- The (internal number of the) accessing
      symbol of state STATE-NUM.  */
 static const yytype_int8 yystos[] =
 {
-       0,    54,     0,     4,     5,     9,    10,    11,    12,    13,
-      14,    15,    19,    20,    21,    26,    27,    36,    55,    56,
-      57,    58,    59,    60,    61,    62,    63,    64,    65,    66,
-      67,    73,    76,    77,    78,    86,     6,     8,     6,     8,
-      47,    50,    79,    47,     7,     3,    29,    31,    47,     3,
-       3,     3,     3,     3,    37,    47,    47,    47,    47,    18,
-      28,    80,    31,     3,     3,    47,    47,    34,    38,    16,
-      35,     3,     3,    47,    47,    47,    30,    32,    82,    47,
-      49,    47,    69,    72,    47,    28,    80,    80,    18,    81,
-      16,    45,    46,    47,    49,    51,    75,    84,     3,    39,
-      29,    18,    68,    22,    23,    24,    25,    71,    16,    47,
-      47,    82,    75,    28,    39,    40,    41,    42,    43,    44,
-      85,    85,    33,    83,    75,     6,    69,    17,    16,    47,
-      80,    81,     3,    18,    74,    47,    47,    75,    47,    75,
-      84,    82,    47,    68,     3,    45,    70,    17,    75,    17,
-      85,    28,    83,     3,     3,    17,     3,    74,     3,    47,
-      75,    47,    28,    47
+       0,    52,     0,     4,     5,     9,    10,    11,    12,    13,
+      14,    15,    19,    20,    21,    25,    26,    35,    53,    54,
+      55,    56,    57,    58,    59,    60,    61,    62,    63,    64,
+      65,    71,    74,    75,    76,    84,     6,     8,     6,     8,
+      46,    49,    77,    46,     7,     3,    28,    30,    46,     3,
+       3,     3,     3,     3,    36,    46,    46,    46,    46,    18,
+      27,    78,    30,     3,     3,    46,    46,    33,    37,    16,
+      34,     3,     3,    46,    46,    46,    29,    31,    80,    46,
+      48,    46,    67,    70,    46,    27,    78,    78,    18,    79,
+      16,    44,    45,    46,    48,    73,    82,     3,    38,    28,
+      18,    66,    22,    23,    24,    69,    16,    46,    46,    80,
+      73,    27,    38,    39,    40,    41,    42,    43,    83,    83,
+      32,    81,    73,     6,    67,    17,    16,    46,    78,    79,
+       3,    18,    72,    46,    46,    73,    46,    73,    82,    80,
+      46,    66,     3,    44,    68,    17,    73,    17,    83,    27,
+      81,     3,     3,    17,     3,    72,     3,    46,    73,    46,
+      27,    46
 };
 
   /* YYR1[YYN] -- Symbol number of symbol that rule YYN derives.  */
 static const yytype_int8 yyr1[] =
 {
-       0,    53,    54,    54,    55,    55,    55,    55,    55,    55,
-      55,    55,    55,    55,    55,    55,    55,    55,    55,    55,
-      55,    56,    57,    58,    59,    60,    61,    62,    63,    64,
-      65,    66,    67,    68,    68,    69,    69,    70,    71,    71,
-      71,    71,    72,    73,    74,    74,    75,    75,    75,    75,
-      76,    77,    78,    79,    79,    79,    80,    80,    80,    81,
-      81,    82,    82,    83,    83,    84,    84,    84,    84,    84,
-      84,    84,    85,    85,    85,    85,    85,    85,    86
+       0,    51,    52,    52,    53,    53,    53,    53,    53,    53,
+      53,    53,    53,    53,    53,    53,    53,    53,    53,    53,
+      53,    54,    55,    56,    57,    58,    59,    60,    61,    62,
+      63,    64,    65,    66,    66,    67,    67,    68,    69,    69,
+      69,    70,    71,    72,    72,    73,    73,    73,    74,    75,
+      76,    77,    77,    77,    78,    78,    78,    79,    79,    80,
+      80,    81,    81,    82,    82,    82,    82,    82,    82,    82,
+      83,    83,    83,    83,    83,    83,    84
 };
 
   /* YYR2[YYN] -- Number of symbols on the right hand side of rule YYN.  */
@@ -836,17 +827,17 @@ static const yytype_int8 yyr2[] =
        1,     1,     1,     1,     1,     1,     1,     1,     1,     1,
        1,     2,     2,     2,     2,     2,     2,     4,     3,     3,
        9,     4,     8,     0,     3,     5,     2,     1,     1,     1,
-       1,     1,     1,     9,     0,     3,     1,     1,     1,     1,
-       5,     8,     7,     1,     2,     4,     0,     3,     5,     0,
-       3,     0,     3,     0,     3,     3,     3,     3,     3,     5,
-       5,     7,     1,     1,     1,     1,     1,     1,     8
+       1,     1,     9,     0,     3,     1,     1,     1,     5,     8,
+       7,     1,     2,     4,     0,     3,     5,     0,     3,     0,
+       3,     0,     3,     3,     3,     3,     3,     5,     5,     7,
+       1,     1,     1,     1,     1,     1,     8
 };
 
 
+enum { YYENOMEM = -2 };
+
 #define yyerrok         (yyerrstatus = 0)
 #define yyclearin       (yychar = YYEMPTY)
-#define YYEMPTY         (-2)
-#define YYEOF           0
 
 #define YYACCEPT        goto yyacceptlab
 #define YYABORT         goto yyabortlab
@@ -872,10 +863,9 @@ static const yytype_int8 yyr2[] =
       }                                                           \
   while (0)
 
-/* Error token number */
-#define YYTERROR        1
-#define YYERRCODE       256
-
+/* Backward compatibility with an undocumented macro.
+   Use YYerror or YYUNDEF. */
+#define YYERRCODE YYUNDEF
 
 
 /* Enable debugging if requested.  */
@@ -893,18 +883,18 @@ do {                                            \
 } while (0)
 
 /* This macro is provided for backward compatibility. */
-#ifndef YY_LOCATION_PRINT
-# define YY_LOCATION_PRINT(File, Loc) ((void) 0)
-#endif
+# ifndef YY_LOCATION_PRINT
+#  define YY_LOCATION_PRINT(File, Loc) ((void) 0)
+# endif
 
 
-# define YY_SYMBOL_PRINT(Title, Type, Value, Location)                    \
+# define YY_SYMBOL_PRINT(Title, Kind, Value, Location)                    \
 do {                                                                      \
   if (yydebug)                                                            \
     {                                                                     \
       YYFPRINTF (stderr, "%s ", Title);                                   \
       yy_symbol_print (stderr,                                            \
-                  Type, Value, scanner); \
+                  Kind, Value, scanner); \
       YYFPRINTF (stderr, "\n");                                           \
     }                                                                     \
 } while (0)
@@ -915,7 +905,8 @@ do {                                                                      \
 `-----------------------------------*/
 
 static void
-yy_symbol_value_print (FILE *yyo, int yytype, YYSTYPE const * const yyvaluep, void *scanner)
+yy_symbol_value_print (FILE *yyo,
+                       yysymbol_kind_t yykind, YYSTYPE const * const yyvaluep, void *scanner)
 {
   FILE *yyoutput = yyo;
   YYUSE (yyoutput);
@@ -923,11 +914,11 @@ yy_symbol_value_print (FILE *yyo, int yytype, YYSTYPE const * const yyvaluep, vo
   if (!yyvaluep)
     return;
 # ifdef YYPRINT
-  if (yytype < YYNTOKENS)
-    YYPRINT (yyo, yytoknum[yytype], *yyvaluep);
+  if (yykind < YYNTOKENS)
+    YYPRINT (yyo, yytoknum[yykind], *yyvaluep);
 # endif
   YY_IGNORE_MAYBE_UNINITIALIZED_BEGIN
-  YYUSE (yytype);
+  YYUSE (yykind);
   YY_IGNORE_MAYBE_UNINITIALIZED_END
 }
 
@@ -937,12 +928,13 @@ yy_symbol_value_print (FILE *yyo, int yytype, YYSTYPE const * const yyvaluep, vo
 `---------------------------*/
 
 static void
-yy_symbol_print (FILE *yyo, int yytype, YYSTYPE const * const yyvaluep, void *scanner)
+yy_symbol_print (FILE *yyo,
+                 yysymbol_kind_t yykind, YYSTYPE const * const yyvaluep, void *scanner)
 {
   YYFPRINTF (yyo, "%s %s (",
-             yytype < YYNTOKENS ? "token" : "nterm", yytname[yytype]);
+             yykind < YYNTOKENS ? "token" : "nterm", yysymbol_name (yykind));
 
-  yy_symbol_value_print (yyo, yytype, yyvaluep, scanner);
+  yy_symbol_value_print (yyo, yykind, yyvaluep, scanner);
   YYFPRINTF (yyo, ")");
 }
 
@@ -975,7 +967,8 @@ do {                                                            \
 `------------------------------------------------*/
 
 static void
-yy_reduce_print (yy_state_t *yyssp, YYSTYPE *yyvsp, int yyrule, void *scanner)
+yy_reduce_print (yy_state_t *yyssp, YYSTYPE *yyvsp,
+                 int yyrule, void *scanner)
 {
   int yylno = yyrline[yyrule];
   int yynrhs = yyr2[yyrule];
@@ -987,9 +980,8 @@ yy_reduce_print (yy_state_t *yyssp, YYSTYPE *yyvsp, int yyrule, void *scanner)
     {
       YYFPRINTF (stderr, "   $%d = ", yyi + 1);
       yy_symbol_print (stderr,
-                       yystos[+yyssp[yyi + 1 - yynrhs]],
-                       &yyvsp[(yyi + 1) - (yynrhs)]
-                                              , scanner);
+                       YY_ACCESSING_SYMBOL (+yyssp[yyi + 1 - yynrhs]),
+                       &yyvsp[(yyi + 1) - (yynrhs)], scanner);
       YYFPRINTF (stderr, "\n");
     }
 }
@@ -1004,8 +996,8 @@ do {                                    \
    multiple parsers can coexist.  */
 int yydebug;
 #else /* !YYDEBUG */
-# define YYDPRINTF(Args)
-# define YY_SYMBOL_PRINT(Title, Type, Value, Location)
+# define YYDPRINTF(Args) ((void) 0)
+# define YY_SYMBOL_PRINT(Title, Kind, Value, Location)
 # define YY_STACK_PRINT(Bottom, Top)
 # define YY_REDUCE_PRINT(Rule)
 #endif /* !YYDEBUG */
@@ -1028,259 +1020,34 @@ int yydebug;
 #endif
 
 
-#if YYERROR_VERBOSE
-
-# ifndef yystrlen
-#  if defined __GLIBC__ && defined _STRING_H
-#   define yystrlen(S) (YY_CAST (YYPTRDIFF_T, strlen (S)))
-#  else
-/* Return the length of YYSTR.  */
-static YYPTRDIFF_T
-yystrlen (const char *yystr)
-{
-  YYPTRDIFF_T yylen;
-  for (yylen = 0; yystr[yylen]; yylen++)
-    continue;
-  return yylen;
-}
-#  endif
-# endif
-
-# ifndef yystpcpy
-#  if defined __GLIBC__ && defined _STRING_H && defined _GNU_SOURCE
-#   define yystpcpy stpcpy
-#  else
-/* Copy YYSRC to YYDEST, returning the address of the terminating '\0' in
-   YYDEST.  */
-static char *
-yystpcpy (char *yydest, const char *yysrc)
-{
-  char *yyd = yydest;
-  const char *yys = yysrc;
-
-  while ((*yyd++ = *yys++) != '\0')
-    continue;
-
-  return yyd - 1;
-}
-#  endif
-# endif
-
-# ifndef yytnamerr
-/* Copy to YYRES the contents of YYSTR after stripping away unnecessary
-   quotes and backslashes, so that it's suitable for yyerror.  The
-   heuristic is that double-quoting is unnecessary unless the string
-   contains an apostrophe, a comma, or backslash (other than
-   backslash-backslash).  YYSTR is taken from yytname.  If YYRES is
-   null, do not copy; instead, return the length of what the result
-   would have been.  */
-static YYPTRDIFF_T
-yytnamerr (char *yyres, const char *yystr)
-{
-  if (*yystr == '"')
-    {
-      YYPTRDIFF_T yyn = 0;
-      char const *yyp = yystr;
-
-      for (;;)
-        switch (*++yyp)
-          {
-          case '\'':
-          case ',':
-            goto do_not_strip_quotes;
-
-          case '\\':
-            if (*++yyp != '\\')
-              goto do_not_strip_quotes;
-            else
-              goto append;
-
-          append:
-          default:
-            if (yyres)
-              yyres[yyn] = *yyp;
-            yyn++;
-            break;
-
-          case '"':
-            if (yyres)
-              yyres[yyn] = '\0';
-            return yyn;
-          }
-    do_not_strip_quotes: ;
-    }
-
-  if (yyres)
-    return yystpcpy (yyres, yystr) - yyres;
-  else
-    return yystrlen (yystr);
-}
-# endif
-
-/* Copy into *YYMSG, which is of size *YYMSG_ALLOC, an error message
-   about the unexpected token YYTOKEN for the state stack whose top is
-   YYSSP.
-
-   Return 0 if *YYMSG was successfully written.  Return 1 if *YYMSG is
-   not large enough to hold the message.  In that case, also set
-   *YYMSG_ALLOC to the required number of bytes.  Return 2 if the
-   required number of bytes is too large to store.  */
-static int
-yysyntax_error (YYPTRDIFF_T *yymsg_alloc, char **yymsg,
-                yy_state_t *yyssp, int yytoken)
-{
-  enum { YYERROR_VERBOSE_ARGS_MAXIMUM = 5 };
-  /* Internationalized format string. */
-  const char *yyformat = YY_NULLPTR;
-  /* Arguments of yyformat: reported tokens (one for the "unexpected",
-     one per "expected"). */
-  char const *yyarg[YYERROR_VERBOSE_ARGS_MAXIMUM];
-  /* Actual size of YYARG. */
-  int yycount = 0;
-  /* Cumulated lengths of YYARG.  */
-  YYPTRDIFF_T yysize = 0;
-
-  /* There are many possibilities here to consider:
-     - If this state is a consistent state with a default action, then
-       the only way this function was invoked is if the default action
-       is an error action.  In that case, don't check for expected
-       tokens because there are none.
-     - The only way there can be no lookahead present (in yychar) is if
-       this state is a consistent state with a default action.  Thus,
-       detecting the absence of a lookahead is sufficient to determine
-       that there is no unexpected or expected token to report.  In that
-       case, just report a simple "syntax error".
-     - Don't assume there isn't a lookahead just because this state is a
-       consistent state with a default action.  There might have been a
-       previous inconsistent state, consistent state with a non-default
-       action, or user semantic action that manipulated yychar.
-     - Of course, the expected token list depends on states to have
-       correct lookahead information, and it depends on the parser not
-       to perform extra reductions after fetching a lookahead from the
-       scanner and before detecting a syntax error.  Thus, state merging
-       (from LALR or IELR) and default reductions corrupt the expected
-       token list.  However, the list is correct for canonical LR with
-       one exception: it will still contain any token that will not be
-       accepted due to an error action in a later state.
-  */
-  if (yytoken != YYEMPTY)
-    {
-      int yyn = yypact[+*yyssp];
-      YYPTRDIFF_T yysize0 = yytnamerr (YY_NULLPTR, yytname[yytoken]);
-      yysize = yysize0;
-      yyarg[yycount++] = yytname[yytoken];
-      if (!yypact_value_is_default (yyn))
-        {
-          /* Start YYX at -YYN if negative to avoid negative indexes in
-             YYCHECK.  In other words, skip the first -YYN actions for
-             this state because they are default actions.  */
-          int yyxbegin = yyn < 0 ? -yyn : 0;
-          /* Stay within bounds of both yycheck and yytname.  */
-          int yychecklim = YYLAST - yyn + 1;
-          int yyxend = yychecklim < YYNTOKENS ? yychecklim : YYNTOKENS;
-          int yyx;
-
-          for (yyx = yyxbegin; yyx < yyxend; ++yyx)
-            if (yycheck[yyx + yyn] == yyx && yyx != YYTERROR
-                && !yytable_value_is_error (yytable[yyx + yyn]))
-              {
-                if (yycount == YYERROR_VERBOSE_ARGS_MAXIMUM)
-                  {
-                    yycount = 1;
-                    yysize = yysize0;
-                    break;
-                  }
-                yyarg[yycount++] = yytname[yyx];
-                {
-                  YYPTRDIFF_T yysize1
-                    = yysize + yytnamerr (YY_NULLPTR, yytname[yyx]);
-                  if (yysize <= yysize1 && yysize1 <= YYSTACK_ALLOC_MAXIMUM)
-                    yysize = yysize1;
-                  else
-                    return 2;
-                }
-              }
-        }
-    }
-
-  switch (yycount)
-    {
-# define YYCASE_(N, S)                      \
-      case N:                               \
-        yyformat = S;                       \
-      break
-    default: /* Avoid compiler warnings. */
-      YYCASE_(0, YY_("syntax error"));
-      YYCASE_(1, YY_("syntax error, unexpected %s"));
-      YYCASE_(2, YY_("syntax error, unexpected %s, expecting %s"));
-      YYCASE_(3, YY_("syntax error, unexpected %s, expecting %s or %s"));
-      YYCASE_(4, YY_("syntax error, unexpected %s, expecting %s or %s or %s"));
-      YYCASE_(5, YY_("syntax error, unexpected %s, expecting %s or %s or %s or %s"));
-# undef YYCASE_
-    }
 
-  {
-    /* Don't count the "%s"s in the final size, but reserve room for
-       the terminator.  */
-    YYPTRDIFF_T yysize1 = yysize + (yystrlen (yyformat) - 2 * yycount) + 1;
-    if (yysize <= yysize1 && yysize1 <= YYSTACK_ALLOC_MAXIMUM)
-      yysize = yysize1;
-    else
-      return 2;
-  }
 
-  if (*yymsg_alloc < yysize)
-    {
-      *yymsg_alloc = 2 * yysize;
-      if (! (yysize <= *yymsg_alloc
-             && *yymsg_alloc <= YYSTACK_ALLOC_MAXIMUM))
-        *yymsg_alloc = YYSTACK_ALLOC_MAXIMUM;
-      return 1;
-    }
 
-  /* Avoid sprintf, as that infringes on the user's name space.
-     Don't have undefined behavior even if the translation
-     produced a string with the wrong number of "%s"s.  */
-  {
-    char *yyp = *yymsg;
-    int yyi = 0;
-    while ((*yyp = *yyformat) != '\0')
-      if (*yyp == '%' && yyformat[1] == 's' && yyi < yycount)
-        {
-          yyp += yytnamerr (yyp, yyarg[yyi++]);
-          yyformat += 2;
-        }
-      else
-        {
-          ++yyp;
-          ++yyformat;
-        }
-  }
-  return 0;
-}
-#endif /* YYERROR_VERBOSE */
 
 /*-----------------------------------------------.
 | Release the memory associated to this symbol.  |
 `-----------------------------------------------*/
 
 static void
-yydestruct (const char *yymsg, int yytype, YYSTYPE *yyvaluep, void *scanner)
+yydestruct (const char *yymsg,
+            yysymbol_kind_t yykind, YYSTYPE *yyvaluep, void *scanner)
 {
   YYUSE (yyvaluep);
   YYUSE (scanner);
   if (!yymsg)
     yymsg = "Deleting";
-  YY_SYMBOL_PRINT (yymsg, yytype, yyvaluep, yylocationp);
+  YY_SYMBOL_PRINT (yymsg, yykind, yyvaluep, yylocationp);
 
   YY_IGNORE_MAYBE_UNINITIALIZED_BEGIN
-  YYUSE (yytype);
+  YYUSE (yykind);
   YY_IGNORE_MAYBE_UNINITIALIZED_END
 }
 
 
 
 
+
+
 /*----------.
 | yyparse.  |
 `----------*/
@@ -1288,7 +1055,7 @@ yydestruct (const char *yymsg, int yytype, YYSTYPE *yyvaluep, void *scanner)
 int
 yyparse (void *scanner)
 {
-/* The lookahead symbol.  */
+/* Lookahead token kind.  */
 int yychar;
 
 
@@ -1299,45 +1066,38 @@ YY_INITIAL_VALUE (static YYSTYPE yyval_default;)
 YYSTYPE yylval YY_INITIAL_VALUE (= yyval_default);
 
     /* Number of syntax errors so far.  */
-    int yynerrs;
+    int yynerrs = 0;
 
-    yy_state_fast_t yystate;
+    yy_state_fast_t yystate = 0;
     /* Number of tokens to shift before error messages enabled.  */
-    int yyerrstatus;
+    int yyerrstatus = 0;
 
-    /* The stacks and their tools:
-       'yyss': related to states.
-       'yyvs': related to semantic values.
-
-       Refer to the stacks through separate pointers, to allow yyoverflow
+    /* Refer to the stacks through separate pointers, to allow yyoverflow
        to reallocate them elsewhere.  */
 
-    /* The state stack.  */
+    /* Their size.  */
+    YYPTRDIFF_T yystacksize = YYINITDEPTH;
+
+    /* The state stack: array, bottom, top.  */
     yy_state_t yyssa[YYINITDEPTH];
-    yy_state_t *yyss;
-    yy_state_t *yyssp;
+    yy_state_t *yyss = yyssa;
+    yy_state_t *yyssp = yyss;
 
-    /* The semantic value stack.  */
+    /* The semantic value stack: array, bottom, top.  */
     YYSTYPE yyvsa[YYINITDEPTH];
-    YYSTYPE *yyvs;
-    YYSTYPE *yyvsp;
-
-    YYPTRDIFF_T yystacksize;
+    YYSTYPE *yyvs = yyvsa;
+    YYSTYPE *yyvsp = yyvs;
 
   int yyn;
+  /* The return value of yyparse.  */
   int yyresult;
-  /* Lookahead token as an internal (translated) token number.  */
-  int yytoken = 0;
+  /* Lookahead symbol kind.  */
+  yysymbol_kind_t yytoken = YYSYMBOL_YYEMPTY;
   /* The variables used to return semantic value and location from the
      action routines.  */
   YYSTYPE yyval;
 
-#if YYERROR_VERBOSE
-  /* Buffer for error messages, and its allocated size.  */
-  char yymsgbuf[128];
-  char *yymsg = yymsgbuf;
-  YYPTRDIFF_T yymsg_alloc = sizeof yymsgbuf;
-#endif
+
 
 #define YYPOPSTACK(N)   (yyvsp -= (N), yyssp -= (N))
 
@@ -1345,15 +1105,8 @@ YYSTYPE yylval YY_INITIAL_VALUE (= yyval_default);
      Keep to zero when no symbol should be popped.  */
   int yylen = 0;
 
-  yyssp = yyss = yyssa;
-  yyvsp = yyvs = yyvsa;
-  yystacksize = YYINITDEPTH;
-
   YYDPRINTF ((stderr, "Starting parse\n"));
 
-  yystate = 0;
-  yyerrstatus = 0;
-  yynerrs = 0;
   yychar = YYEMPTY; /* Cause a token to be read.  */
   goto yysetstate;
 
@@ -1376,6 +1129,7 @@ yysetstate:
   YY_IGNORE_USELESS_CAST_BEGIN
   *yyssp = YY_CAST (yy_state_t, yystate);
   YY_IGNORE_USELESS_CAST_END
+  YY_STACK_PRINT (yyss, yyssp);
 
   if (yyss + yystacksize - 1 <= yyssp)
 #if !defined yyoverflow && !defined YYSTACK_RELOCATE
@@ -1421,7 +1175,7 @@ yysetstate:
           goto yyexhaustedlab;
         YYSTACK_RELOCATE (yyss_alloc, yyss);
         YYSTACK_RELOCATE (yyvs_alloc, yyvs);
-# undef YYSTACK_RELOCATE
+#  undef YYSTACK_RELOCATE
         if (yyss1 != yyssa)
           YYSTACK_FREE (yyss1);
       }
@@ -1460,18 +1214,29 @@ yybackup:
 
   /* Not known => get a lookahead token if don't already have one.  */
 
-  /* YYCHAR is either YYEMPTY or YYEOF or a valid lookahead symbol.  */
+  /* YYCHAR is either empty, or end-of-input, or a valid lookahead.  */
   if (yychar == YYEMPTY)
     {
-      YYDPRINTF ((stderr, "Reading a token: "));
+      YYDPRINTF ((stderr, "Reading a token\n"));
       yychar = yylex (&yylval, scanner);
     }
 
   if (yychar <= YYEOF)
     {
-      yychar = yytoken = YYEOF;
+      yychar = YYEOF;
+      yytoken = YYSYMBOL_YYEOF;
       YYDPRINTF ((stderr, "Now at end of input.\n"));
     }
+  else if (yychar == YYerror)
+    {
+      /* The scanner already issued an error message, process directly
+         to error recovery.  But do not keep the error token as
+         lookahead, it is too special and may lead us to an endless
+         loop in error recovery. */
+      yychar = YYUNDEF;
+      yytoken = YYSYMBOL_YYerror;
+      goto yyerrlab1;
+    }
   else
     {
       yytoken = YYTRANSLATE (yychar);
@@ -1540,100 +1305,100 @@ yyreduce:
   YY_REDUCE_PRINT (yyn);
   switch (yyn)
     {
-  case 21:
-#line 172 "yacc_sql.y"
+  case 21: /* exit: EXIT SEMICOLON  */
+#line 158 "yacc_sql.y"
                    {
         CONTEXT->ssql->flag=SCF_EXIT;//"exit";
     }
-#line 1549 "yacc_sql.tab.c"
+#line 1314 "yacc_sql.tab.c"
     break;
 
-  case 22:
-#line 177 "yacc_sql.y"
+  case 22: /* help: HELP SEMICOLON  */
+#line 163 "yacc_sql.y"
                    {
         CONTEXT->ssql->flag=SCF_HELP;//"help";
     }
-#line 1557 "yacc_sql.tab.c"
+#line 1322 "yacc_sql.tab.c"
     break;
 
-  case 23:
-#line 182 "yacc_sql.y"
+  case 23: /* sync: SYNC SEMICOLON  */
+#line 168 "yacc_sql.y"
                    {
       CONTEXT->ssql->flag = SCF_SYNC;
     }
-#line 1565 "yacc_sql.tab.c"
+#line 1330 "yacc_sql.tab.c"
     break;
 
-  case 24:
-#line 188 "yacc_sql.y"
+  case 24: /* begin: TRX_BEGIN SEMICOLON  */
+#line 174 "yacc_sql.y"
                         {
       CONTEXT->ssql->flag = SCF_BEGIN;
     }
-#line 1573 "yacc_sql.tab.c"
+#line 1338 "yacc_sql.tab.c"
     break;
 
-  case 25:
-#line 194 "yacc_sql.y"
+  case 25: /* commit: TRX_COMMIT SEMICOLON  */
+#line 180 "yacc_sql.y"
                          {
       CONTEXT->ssql->flag = SCF_COMMIT;
     }
-#line 1581 "yacc_sql.tab.c"
+#line 1346 "yacc_sql.tab.c"
     break;
 
-  case 26:
-#line 200 "yacc_sql.y"
+  case 26: /* rollback: TRX_ROLLBACK SEMICOLON  */
+#line 186 "yacc_sql.y"
                            {
       CONTEXT->ssql->flag = SCF_ROLLBACK;
     }
-#line 1589 "yacc_sql.tab.c"
+#line 1354 "yacc_sql.tab.c"
     break;
 
-  case 27:
-#line 206 "yacc_sql.y"
+  case 27: /* drop_table: DROP TABLE ID SEMICOLON  */
+#line 192 "yacc_sql.y"
                             {
         CONTEXT->ssql->flag = SCF_DROP_TABLE;//"drop_table";
         drop_table_init(&CONTEXT->ssql->sstr.drop_table, (yyvsp[-1].string));
     }
-#line 1598 "yacc_sql.tab.c"
+#line 1363 "yacc_sql.tab.c"
     break;
 
-  case 28:
-#line 212 "yacc_sql.y"
+  case 28: /* show_tables: SHOW TABLES SEMICOLON  */
+#line 198 "yacc_sql.y"
                           {
       CONTEXT->ssql->flag = SCF_SHOW_TABLES;
     }
-#line 1606 "yacc_sql.tab.c"
+#line 1371 "yacc_sql.tab.c"
     break;
 
-  case 29:
-#line 218 "yacc_sql.y"
+  case 29: /* desc_table: DESC ID SEMICOLON  */
+#line 204 "yacc_sql.y"
                       {
       CONTEXT->ssql->flag = SCF_DESC_TABLE;
       desc_table_init(&CONTEXT->ssql->sstr.desc_table, (yyvsp[-1].string));
     }
-#line 1615 "yacc_sql.tab.c"
+#line 1380 "yacc_sql.tab.c"
     break;
 
-  case 30:
-#line 226 "yacc_sql.y"
+  case 30: /* create_index: CREATE INDEX ID ON ID LBRACE ID RBRACE SEMICOLON  */
+#line 212 "yacc_sql.y"
                 {
 			CONTEXT->ssql->flag = SCF_CREATE_INDEX;//"create_index";
 			create_index_init(&CONTEXT->ssql->sstr.create_index, (yyvsp[-6].string), (yyvsp[-4].string), (yyvsp[-2].string));
 		}
-#line 1624 "yacc_sql.tab.c"
+#line 1389 "yacc_sql.tab.c"
     break;
 
-  case 31:
-#line 234 "yacc_sql.y"
+  case 31: /* drop_index: DROP INDEX ID SEMICOLON  */
+#line 220 "yacc_sql.y"
                 {
 			CONTEXT->ssql->flag=SCF_DROP_INDEX;//"drop_index";
 			drop_index_init(&CONTEXT->ssql->sstr.drop_index, (yyvsp[-1].string));
 		}
-#line 1633 "yacc_sql.tab.c"
+#line 1398 "yacc_sql.tab.c"
     break;
 
-  case 32:
-#line 241 "yacc_sql.y"
+  case 32: /* create_table: CREATE TABLE ID LBRACE attr_def attr_def_list RBRACE SEMICOLON  */
+#line 227 "yacc_sql.y"
                 {
 			CONTEXT->ssql->flag=SCF_CREATE_TABLE;//"create_table";
 			// CONTEXT->ssql->sstr.create_table.attribute_count = CONTEXT->value_length;
@@ -1641,17 +1406,17 @@ yyreduce:
 			//临时变量清零	
 			CONTEXT->value_length = 0;
 		}
-#line 1645 "yacc_sql.tab.c"
+#line 1410 "yacc_sql.tab.c"
     break;
 
-  case 34:
-#line 251 "yacc_sql.y"
+  case 34: /* attr_def_list: COMMA attr_def attr_def_list  */
+#line 237 "yacc_sql.y"
                                    {    }
-#line 1651 "yacc_sql.tab.c"
+#line 1416 "yacc_sql.tab.c"
     break;
 
-  case 35:
-#line 256 "yacc_sql.y"
+  case 35: /* attr_def: ID_get type LBRACE number RBRACE  */
+#line 242 "yacc_sql.y"
                 {
 			AttrInfo attribute;
 			attr_info_init(&attribute, CONTEXT->id, (yyvsp[-3].number), (yyvsp[-1].number));
@@ -1662,11 +1427,11 @@ yyreduce:
 			// CONTEXT->ssql->sstr.create_table.attributes[CONTEXT->value_length].length = $4;
 			CONTEXT->value_length++;
 		}
-#line 1666 "yacc_sql.tab.c"
+#line 1431 "yacc_sql.tab.c"
     break;
 
-  case 36:
-#line 267 "yacc_sql.y"
+  case 36: /* attr_def: ID_get type  */
+#line 253 "yacc_sql.y"
                 {
 			AttrInfo attribute;
 			attr_info_init(&attribute, CONTEXT->id, (yyvsp[0].number), 4);
@@ -1677,50 +1442,44 @@ yyreduce:
 			// CONTEXT->ssql->sstr.create_table.attributes[CONTEXT->value_length].length=4; // default attribute length
 			CONTEXT->value_length++;
 		}
-#line 1681 "yacc_sql.tab.c"
+#line 1446 "yacc_sql.tab.c"
     break;
 
-  case 37:
-#line 279 "yacc_sql.y"
+  case 37: /* number: NUMBER  */
+#line 265 "yacc_sql.y"
                        {(yyval.number) = (yyvsp[0].number);}
-#line 1687 "yacc_sql.tab.c"
+#line 1452 "yacc_sql.tab.c"
     break;
 
-  case 38:
-#line 282 "yacc_sql.y"
+  case 38: /* type: INT_T  */
+#line 268 "yacc_sql.y"
               { (yyval.number)=INTS; }
-#line 1693 "yacc_sql.tab.c"
+#line 1458 "yacc_sql.tab.c"
     break;
 
-  case 39:
-#line 283 "yacc_sql.y"
+  case 39: /* type: STRING_T  */
+#line 269 "yacc_sql.y"
                   { (yyval.number)=CHARS; }
-#line 1699 "yacc_sql.tab.c"
+#line 1464 "yacc_sql.tab.c"
     break;
 
-  case 40:
-#line 284 "yacc_sql.y"
+  case 40: /* type: FLOAT_T  */
+#line 270 "yacc_sql.y"
                  { (yyval.number)=FLOATS; }
-#line 1705 "yacc_sql.tab.c"
+#line 1470 "yacc_sql.tab.c"
     break;
 
-  case 41:
-#line 285 "yacc_sql.y"
-                    {(yyval.number)=DATES;}
-#line 1711 "yacc_sql.tab.c"
-    break;
-
-  case 42:
-#line 289 "yacc_sql.y"
+  case 41: /* ID_get: ID  */
+#line 274 "yacc_sql.y"
         {
 		char *temp=(yyvsp[0].string); 
 		snprintf(CONTEXT->id, sizeof(CONTEXT->id), "%s", temp);
 	}
-#line 1720 "yacc_sql.tab.c"
+#line 1479 "yacc_sql.tab.c"
     break;
 
-  case 43:
-#line 298 "yacc_sql.y"
+  case 42: /* insert: INSERT INTO ID VALUES LBRACE value value_list RBRACE SEMICOLON  */
+#line 283 "yacc_sql.y"
                 {
 			// CONTEXT->values[CONTEXT->value_length++] = *$6;
 
@@ -1735,55 +1494,44 @@ yyreduce:
       //临时变量清零
       CONTEXT->value_length=0;
     }
-#line 1739 "yacc_sql.tab.c"
+#line 1498 "yacc_sql.tab.c"
     break;
 
-  case 45:
-#line 315 "yacc_sql.y"
+  case 44: /* value_list: COMMA value value_list  */
+#line 300 "yacc_sql.y"
                               { 
   		// CONTEXT->values[CONTEXT->value_length++] = *$2;
 	  }
-#line 1747 "yacc_sql.tab.c"
+#line 1506 "yacc_sql.tab.c"
     break;
 
-  case 46:
-#line 320 "yacc_sql.y"
+  case 45: /* value: NUMBER  */
+#line 305 "yacc_sql.y"
           {	
   		value_init_integer(&CONTEXT->values[CONTEXT->value_length++], (yyvsp[0].number));
 		}
-#line 1755 "yacc_sql.tab.c"
+#line 1514 "yacc_sql.tab.c"
     break;
 
-  case 47:
-#line 323 "yacc_sql.y"
+  case 46: /* value: FLOAT  */
+#line 308 "yacc_sql.y"
           {
   		value_init_float(&CONTEXT->values[CONTEXT->value_length++], (yyvsp[0].floats));
 		}
-#line 1763 "yacc_sql.tab.c"
+#line 1522 "yacc_sql.tab.c"
     break;
 
-  case 48:
-#line 326 "yacc_sql.y"
-             {
-		(yyvsp[0].string) = substr((yyvsp[0].string),1,strlen((yyvsp[0].string))-2);
-		value_init_date(&CONTEXT->values[CONTEXT->value_length++], (yyvsp[0].string));
-		//if(check_date(*(int *)(CONTEXT->values[CONTEXT->value_length].data))==0)
-		//yyerror_date(scanner);
-	}
-#line 1774 "yacc_sql.tab.c"
-    break;
-
-  case 49:
-#line 332 "yacc_sql.y"
+  case 47: /* value: SSS  */
+#line 311 "yacc_sql.y"
          {
-		(yyvsp[0].string) = substr((yyvsp[0].string),1,strlen((yyvsp[0].string))-2);
+			(yyvsp[0].string) = substr((yyvsp[0].string),1,strlen((yyvsp[0].string))-2);
   		value_init_string(&CONTEXT->values[CONTEXT->value_length++], (yyvsp[0].string));
-	}
-#line 1783 "yacc_sql.tab.c"
+		}
+#line 1531 "yacc_sql.tab.c"
     break;
 
-  case 50:
-#line 340 "yacc_sql.y"
+  case 48: /* delete: DELETE FROM ID where SEMICOLON  */
+#line 319 "yacc_sql.y"
                 {
 			CONTEXT->ssql->flag = SCF_DELETE;//"delete";
 			deletes_init_relation(&CONTEXT->ssql->sstr.deletion, (yyvsp[-2].string));
@@ -1791,11 +1539,11 @@ yyreduce:
 					CONTEXT->conditions, CONTEXT->condition_length);
 			CONTEXT->condition_length = 0;	
     }
-#line 1795 "yacc_sql.tab.c"
+#line 1543 "yacc_sql.tab.c"
     break;
 
-  case 51:
-#line 350 "yacc_sql.y"
+  case 49: /* update: UPDATE ID SET ID EQ value where SEMICOLON  */
+#line 329 "yacc_sql.y"
                 {
 			CONTEXT->ssql->flag = SCF_UPDATE;//"update";
 			Value *value = &CONTEXT->values[0];
@@ -1803,11 +1551,11 @@ yyreduce:
 					CONTEXT->conditions, CONTEXT->condition_length);
 			CONTEXT->condition_length = 0;
 		}
-#line 1807 "yacc_sql.tab.c"
+#line 1555 "yacc_sql.tab.c"
     break;
 
-  case 52:
-#line 360 "yacc_sql.y"
+  case 50: /* select: SELECT select_attr FROM ID rel_list where SEMICOLON  */
+#line 339 "yacc_sql.y"
                 {
 			// CONTEXT->ssql->sstr.selection.relations[CONTEXT->from_length++]=$4;
 			selects_append_relation(&CONTEXT->ssql->sstr.selection, (yyvsp[-3].string));
@@ -1823,41 +1571,41 @@ yyreduce:
 			CONTEXT->select_length=0;
 			CONTEXT->value_length = 0;
 	}
-#line 1827 "yacc_sql.tab.c"
+#line 1575 "yacc_sql.tab.c"
     break;
 
-  case 53:
-#line 378 "yacc_sql.y"
+  case 51: /* select_attr: STAR  */
+#line 357 "yacc_sql.y"
          {  
 			RelAttr attr;
 			relation_attr_init(&attr, NULL, "*");
 			selects_append_attribute(&CONTEXT->ssql->sstr.selection, &attr);
 		}
-#line 1837 "yacc_sql.tab.c"
+#line 1585 "yacc_sql.tab.c"
     break;
 
-  case 54:
-#line 383 "yacc_sql.y"
+  case 52: /* select_attr: ID attr_list  */
+#line 362 "yacc_sql.y"
                    {
 			RelAttr attr;
 			relation_attr_init(&attr, NULL, (yyvsp[-1].string));
 			selects_append_attribute(&CONTEXT->ssql->sstr.selection, &attr);
 		}
-#line 1847 "yacc_sql.tab.c"
+#line 1595 "yacc_sql.tab.c"
     break;
 
-  case 55:
-#line 388 "yacc_sql.y"
+  case 53: /* select_attr: ID DOT ID attr_list  */
+#line 367 "yacc_sql.y"
                               {
 			RelAttr attr;
 			relation_attr_init(&attr, (yyvsp[-3].string), (yyvsp[-1].string));
 			selects_append_attribute(&CONTEXT->ssql->sstr.selection, &attr);
 		}
-#line 1857 "yacc_sql.tab.c"
+#line 1605 "yacc_sql.tab.c"
     break;
 
-  case 57:
-#line 396 "yacc_sql.y"
+  case 55: /* attr_list: COMMA ID attr_list  */
+#line 375 "yacc_sql.y"
                          {
 			RelAttr attr;
 			relation_attr_init(&attr, NULL, (yyvsp[-1].string));
@@ -1865,11 +1613,11 @@ yyreduce:
      	  // CONTEXT->ssql->sstr.selection.attributes[CONTEXT->select_length].relation_name = NULL;
         // CONTEXT->ssql->sstr.selection.attributes[CONTEXT->select_length++].attribute_name=$2;
       }
-#line 1869 "yacc_sql.tab.c"
+#line 1617 "yacc_sql.tab.c"
     break;
 
-  case 58:
-#line 403 "yacc_sql.y"
+  case 56: /* attr_list: COMMA ID DOT ID attr_list  */
+#line 382 "yacc_sql.y"
                                 {
 			RelAttr attr;
 			relation_attr_init(&attr, (yyvsp[-3].string), (yyvsp[-1].string));
@@ -1877,35 +1625,35 @@ yyreduce:
         // CONTEXT->ssql->sstr.selection.attributes[CONTEXT->select_length].attribute_name=$4;
         // CONTEXT->ssql->sstr.selection.attributes[CONTEXT->select_length++].relation_name=$2;
   	  }
-#line 1881 "yacc_sql.tab.c"
+#line 1629 "yacc_sql.tab.c"
     break;
 
-  case 60:
-#line 414 "yacc_sql.y"
+  case 58: /* rel_list: COMMA ID rel_list  */
+#line 393 "yacc_sql.y"
                         {	
 				selects_append_relation(&CONTEXT->ssql->sstr.selection, (yyvsp[-1].string));
 		  }
-#line 1889 "yacc_sql.tab.c"
+#line 1637 "yacc_sql.tab.c"
     break;
 
-  case 62:
-#line 420 "yacc_sql.y"
+  case 60: /* where: WHERE condition condition_list  */
+#line 399 "yacc_sql.y"
                                      {	
 				// CONTEXT->conditions[CONTEXT->condition_length++]=*$2;
 			}
-#line 1897 "yacc_sql.tab.c"
+#line 1645 "yacc_sql.tab.c"
     break;
 
-  case 64:
-#line 426 "yacc_sql.y"
+  case 62: /* condition_list: AND condition condition_list  */
+#line 405 "yacc_sql.y"
                                    {
 				// CONTEXT->conditions[CONTEXT->condition_length++]=*$2;
 			}
-#line 1905 "yacc_sql.tab.c"
+#line 1653 "yacc_sql.tab.c"
     break;
 
-  case 65:
-#line 432 "yacc_sql.y"
+  case 63: /* condition: ID comOp value  */
+#line 411 "yacc_sql.y"
                 {
 			RelAttr left_attr;
 			relation_attr_init(&left_attr, NULL, (yyvsp[-2].string));
@@ -1926,11 +1674,11 @@ yyreduce:
 			// $$->right_value = *$3;
 
 		}
-#line 1930 "yacc_sql.tab.c"
+#line 1678 "yacc_sql.tab.c"
     break;
 
-  case 66:
-#line 453 "yacc_sql.y"
+  case 64: /* condition: value comOp value  */
+#line 432 "yacc_sql.y"
                 {
 			Value *left_value = &CONTEXT->values[CONTEXT->value_length - 2];
 			Value *right_value = &CONTEXT->values[CONTEXT->value_length - 1];
@@ -1950,11 +1698,11 @@ yyreduce:
 			// $$->right_value = *$3;
 
 		}
-#line 1954 "yacc_sql.tab.c"
+#line 1702 "yacc_sql.tab.c"
     break;
 
-  case 67:
-#line 473 "yacc_sql.y"
+  case 65: /* condition: ID comOp ID  */
+#line 452 "yacc_sql.y"
                 {
 			RelAttr left_attr;
 			relation_attr_init(&left_attr, NULL, (yyvsp[-2].string));
@@ -1974,11 +1722,11 @@ yyreduce:
 			// $$->right_attr.attribute_name=$3;
 
 		}
-#line 1978 "yacc_sql.tab.c"
+#line 1726 "yacc_sql.tab.c"
     break;
 
-  case 68:
-#line 493 "yacc_sql.y"
+  case 66: /* condition: value comOp ID  */
+#line 472 "yacc_sql.y"
                 {
 			Value *left_value = &CONTEXT->values[CONTEXT->value_length - 1];
 			RelAttr right_attr;
@@ -2000,11 +1748,11 @@ yyreduce:
 			// $$->right_attr.attribute_name=$3;
 		
 		}
-#line 2004 "yacc_sql.tab.c"
+#line 1752 "yacc_sql.tab.c"
     break;
 
-  case 69:
-#line 515 "yacc_sql.y"
+  case 67: /* condition: ID DOT ID comOp value  */
+#line 494 "yacc_sql.y"
                 {
 			RelAttr left_attr;
 			relation_attr_init(&left_attr, (yyvsp[-4].string), (yyvsp[-2].string));
@@ -2025,11 +1773,11 @@ yyreduce:
 			// $$->right_value =*$5;			
 							
     }
-#line 2029 "yacc_sql.tab.c"
+#line 1777 "yacc_sql.tab.c"
     break;
 
-  case 70:
-#line 536 "yacc_sql.y"
+  case 68: /* condition: value comOp ID DOT ID  */
+#line 515 "yacc_sql.y"
                 {
 			Value *left_value = &CONTEXT->values[CONTEXT->value_length - 1];
 
@@ -2050,11 +1798,11 @@ yyreduce:
 			// $$->right_attr.attribute_name = $5;
 									
     }
-#line 2054 "yacc_sql.tab.c"
+#line 1802 "yacc_sql.tab.c"
     break;
 
-  case 71:
-#line 557 "yacc_sql.y"
+  case 69: /* condition: ID DOT ID comOp ID DOT ID  */
+#line 536 "yacc_sql.y"
                 {
 			RelAttr left_attr;
 			relation_attr_init(&left_attr, (yyvsp[-6].string), (yyvsp[-4].string));
@@ -2073,56 +1821,56 @@ yyreduce:
 			// $$->right_attr.relation_name=$5;
 			// $$->right_attr.attribute_name=$7;
     }
-#line 2077 "yacc_sql.tab.c"
+#line 1825 "yacc_sql.tab.c"
     break;
 
-  case 72:
-#line 578 "yacc_sql.y"
+  case 70: /* comOp: EQ  */
+#line 557 "yacc_sql.y"
              { CONTEXT->comp = EQUAL_TO; }
-#line 2083 "yacc_sql.tab.c"
+#line 1831 "yacc_sql.tab.c"
     break;
 
-  case 73:
-#line 579 "yacc_sql.y"
+  case 71: /* comOp: LT  */
+#line 558 "yacc_sql.y"
          { CONTEXT->comp = LESS_THAN; }
-#line 2089 "yacc_sql.tab.c"
+#line 1837 "yacc_sql.tab.c"
     break;
 
-  case 74:
-#line 580 "yacc_sql.y"
+  case 72: /* comOp: GT  */
+#line 559 "yacc_sql.y"
          { CONTEXT->comp = GREAT_THAN; }
-#line 2095 "yacc_sql.tab.c"
+#line 1843 "yacc_sql.tab.c"
     break;
 
-  case 75:
-#line 581 "yacc_sql.y"
+  case 73: /* comOp: LE  */
+#line 560 "yacc_sql.y"
          { CONTEXT->comp = LESS_EQUAL; }
-#line 2101 "yacc_sql.tab.c"
+#line 1849 "yacc_sql.tab.c"
     break;
 
-  case 76:
-#line 582 "yacc_sql.y"
+  case 74: /* comOp: GE  */
+#line 561 "yacc_sql.y"
          { CONTEXT->comp = GREAT_EQUAL; }
-#line 2107 "yacc_sql.tab.c"
+#line 1855 "yacc_sql.tab.c"
     break;
 
-  case 77:
-#line 583 "yacc_sql.y"
+  case 75: /* comOp: NE  */
+#line 562 "yacc_sql.y"
          { CONTEXT->comp = NOT_EQUAL; }
-#line 2113 "yacc_sql.tab.c"
+#line 1861 "yacc_sql.tab.c"
     break;
 
-  case 78:
-#line 588 "yacc_sql.y"
+  case 76: /* load_data: LOAD DATA INFILE SSS INTO TABLE ID SEMICOLON  */
+#line 567 "yacc_sql.y"
                 {
 		  CONTEXT->ssql->flag = SCF_LOAD_DATA;
 			load_data_init(&CONTEXT->ssql->sstr.load_data, (yyvsp[-1].string), (yyvsp[-4].string));
 		}
-#line 2122 "yacc_sql.tab.c"
+#line 1870 "yacc_sql.tab.c"
     break;
 
 
-#line 2126 "yacc_sql.tab.c"
+#line 1874 "yacc_sql.tab.c"
 
       default: break;
     }
@@ -2137,11 +1885,10 @@ yyreduce:
      case of YYERROR or YYBACKUP, subsequent parser actions might lead
      to an incorrect destructor call or verbose syntax error message
      before the lookahead is translated.  */
-  YY_SYMBOL_PRINT ("-> $$ =", yyr1[yyn], &yyval, &yyloc);
+  YY_SYMBOL_PRINT ("-> $$ =", YY_CAST (yysymbol_kind_t, yyr1[yyn]), &yyval, &yyloc);
 
   YYPOPSTACK (yylen);
   yylen = 0;
-  YY_STACK_PRINT (yyss, yyssp);
 
   *++yyvsp = yyval;
 
@@ -2165,50 +1912,14 @@ yyreduce:
 yyerrlab:
   /* Make sure we have latest lookahead translation.  See comments at
      user semantic actions for why this is necessary.  */
-  yytoken = yychar == YYEMPTY ? YYEMPTY : YYTRANSLATE (yychar);
-
+  yytoken = yychar == YYEMPTY ? YYSYMBOL_YYEMPTY : YYTRANSLATE (yychar);
   /* If not already recovering from an error, report this error.  */
   if (!yyerrstatus)
     {
       ++yynerrs;
-#if ! YYERROR_VERBOSE
       yyerror (scanner, YY_("syntax error"));
-#else
-# define YYSYNTAX_ERROR yysyntax_error (&yymsg_alloc, &yymsg, \
-                                        yyssp, yytoken)
-      {
-        char const *yymsgp = YY_("syntax error");
-        int yysyntax_error_status;
-        yysyntax_error_status = YYSYNTAX_ERROR;
-        if (yysyntax_error_status == 0)
-          yymsgp = yymsg;
-        else if (yysyntax_error_status == 1)
-          {
-            if (yymsg != yymsgbuf)
-              YYSTACK_FREE (yymsg);
-            yymsg = YY_CAST (char *, YYSTACK_ALLOC (YY_CAST (YYSIZE_T, yymsg_alloc)));
-            if (!yymsg)
-              {
-                yymsg = yymsgbuf;
-                yymsg_alloc = sizeof yymsgbuf;
-                yysyntax_error_status = 2;
-              }
-            else
-              {
-                yysyntax_error_status = YYSYNTAX_ERROR;
-                yymsgp = yymsg;
-              }
-          }
-        yyerror (scanner, yymsgp);
-        if (yysyntax_error_status == 2)
-          goto yyexhaustedlab;
-      }
-# undef YYSYNTAX_ERROR
-#endif
     }
 
-
-
   if (yyerrstatus == 3)
     {
       /* If just tried and failed to reuse lookahead token after an
@@ -2257,13 +1968,14 @@ yyerrorlab:
 yyerrlab1:
   yyerrstatus = 3;      /* Each real token shifted decrements this.  */
 
+  /* Pop stack until we find a state that shifts the error token.  */
   for (;;)
     {
       yyn = yypact[yystate];
       if (!yypact_value_is_default (yyn))
         {
-          yyn += YYTERROR;
-          if (0 <= yyn && yyn <= YYLAST && yycheck[yyn] == YYTERROR)
+          yyn += YYSYMBOL_YYerror;
+          if (0 <= yyn && yyn <= YYLAST && yycheck[yyn] == YYSYMBOL_YYerror)
             {
               yyn = yytable[yyn];
               if (0 < yyn)
@@ -2277,7 +1989,7 @@ yyerrlab1:
 
 
       yydestruct ("Error: popping",
-                  yystos[yystate], yyvsp, scanner);
+                  YY_ACCESSING_SYMBOL (yystate), yyvsp, scanner);
       YYPOPSTACK (1);
       yystate = *yyssp;
       YY_STACK_PRINT (yyss, yyssp);
@@ -2289,7 +2001,7 @@ yyerrlab1:
 
 
   /* Shift the error token.  */
-  YY_SYMBOL_PRINT ("Shifting", yystos[yyn], yyvsp, yylsp);
+  YY_SYMBOL_PRINT ("Shifting", YY_ACCESSING_SYMBOL (yyn), yyvsp, yylsp);
 
   yystate = yyn;
   goto yynewstate;
@@ -2311,20 +2023,20 @@ yyabortlab:
   goto yyreturn;
 
 
-#if !defined yyoverflow || YYERROR_VERBOSE
+#if !defined yyoverflow
 /*-------------------------------------------------.
 | yyexhaustedlab -- memory exhaustion comes here.  |
 `-------------------------------------------------*/
 yyexhaustedlab:
   yyerror (scanner, YY_("memory exhausted"));
   yyresult = 2;
-  /* Fall through.  */
+  goto yyreturn;
 #endif
 
 
-/*-----------------------------------------------------.
-| yyreturn -- parsing is finished, return the result.  |
-`-----------------------------------------------------*/
+/*-------------------------------------------------------.
+| yyreturn -- parsing is finished, clean up and return.  |
+`-------------------------------------------------------*/
 yyreturn:
   if (yychar != YYEMPTY)
     {
@@ -2341,37 +2053,22 @@ yyreturn:
   while (yyssp != yyss)
     {
       yydestruct ("Cleanup: popping",
-                  yystos[+*yyssp], yyvsp, scanner);
+                  YY_ACCESSING_SYMBOL (+*yyssp), yyvsp, scanner);
       YYPOPSTACK (1);
     }
 #ifndef yyoverflow
   if (yyss != yyssa)
     YYSTACK_FREE (yyss);
 #endif
-#if YYERROR_VERBOSE
-  if (yymsg != yymsgbuf)
-    YYSTACK_FREE (yymsg);
-#endif
+
   return yyresult;
 }
-#line 593 "yacc_sql.y"
+
+#line 572 "yacc_sql.y"
 
 //_____________________________________________________________________
 extern void scan_string(const char *str, yyscan_t scanner);
 
-int check_date(int date){
-    int year = date/10000;
-    int month = date/100-year*100;
-    int datetime = date-10000*year-100*month;
-	//LOG_INFO("The date is:%d,%d,%d",year,month,datetime);
-    int Month_buf[12] = { 31,28,31,30,31,30,31,31,30,31,30,31 };  //月份修正表
-    if(month==2)                                                             //闰年2月+1天
-        (((year%4==0)&&(year%100!=0))||(year%400==0))?Month_buf[1]+=1:Month_buf[1];
-    if (month>12||month<1||datetime>Month_buf[month-1]||datetime<1)           //判断月份日期是否合法
-        return 0;
-    return 1;
-}
-
 int sql_parse(const char *s, Query *sqls){
 	ParserContext context;
 	memset(&context, 0, sizeof(context));
diff --git a/src/observer/sql/parser/yacc_sql.tab.h b/src/observer/sql/parser/yacc_sql.tab.h
index f102d7a..9116658 100644
--- a/src/observer/sql/parser/yacc_sql.tab.h
+++ b/src/observer/sql/parser/yacc_sql.tab.h
@@ -1,4 +1,4 @@
-/* A Bison parser, made by GNU Bison 3.5.1.  */
+/* A Bison parser, made by GNU Bison 3.7.  */
 
 /* Bison interface for Yacc-like parsers in C
 
@@ -31,8 +31,9 @@
    This special exception was added by the Free Software Foundation in
    version 2.2 of Bison.  */
 
-/* Undocumented macros, especially those whose name start with YY_,
-   are private implementation details.  Do not rely on them.  */
+/* DO NOT RELY ON FEATURES THAT ARE NOT DOCUMENTED in the manual,
+   especially those whose name start with YY_ or yy_.  They are
+   private implementation details that can be changed or removed.  */
 
 #ifndef YY_YY_YACC_SQL_TAB_H_INCLUDED
 # define YY_YY_YACC_SQL_TAB_H_INCLUDED
@@ -44,80 +45,82 @@
 extern int yydebug;
 #endif
 
-/* Token type.  */
+/* Token kinds.  */
 #ifndef YYTOKENTYPE
 # define YYTOKENTYPE
   enum yytokentype
   {
-    SEMICOLON = 258,
-    CREATE = 259,
-    DROP = 260,
-    TABLE = 261,
-    TABLES = 262,
-    INDEX = 263,
-    SELECT = 264,
-    DESC = 265,
-    SHOW = 266,
-    SYNC = 267,
-    INSERT = 268,
-    DELETE = 269,
-    UPDATE = 270,
-    LBRACE = 271,
-    RBRACE = 272,
-    COMMA = 273,
-    TRX_BEGIN = 274,
-    TRX_COMMIT = 275,
-    TRX_ROLLBACK = 276,
-    INT_T = 277,
-    STRING_T = 278,
-    FLOAT_T = 279,
-    DATE_T = 280,
-    HELP = 281,
-    EXIT = 282,
-    DOT = 283,
-    INTO = 284,
-    VALUES = 285,
-    FROM = 286,
-    WHERE = 287,
-    AND = 288,
-    SET = 289,
-    ON = 290,
-    LOAD = 291,
-    DATA = 292,
-    INFILE = 293,
-    EQ = 294,
-    LT = 295,
-    GT = 296,
-    LE = 297,
-    GE = 298,
-    NE = 299,
-    NUMBER = 300,
-    FLOAT = 301,
-    ID = 302,
-    PATH = 303,
-    SSS = 304,
-    STAR = 305,
-    DATE = 306,
-    STRING_V = 307
+    YYEMPTY = -2,
+    YYEOF = 0,                     /* "end of file"  */
+    YYerror = 256,                 /* error  */
+    YYUNDEF = 257,                 /* "invalid token"  */
+    SEMICOLON = 258,               /* SEMICOLON  */
+    CREATE = 259,                  /* CREATE  */
+    DROP = 260,                    /* DROP  */
+    TABLE = 261,                   /* TABLE  */
+    TABLES = 262,                  /* TABLES  */
+    INDEX = 263,                   /* INDEX  */
+    SELECT = 264,                  /* SELECT  */
+    DESC = 265,                    /* DESC  */
+    SHOW = 266,                    /* SHOW  */
+    SYNC = 267,                    /* SYNC  */
+    INSERT = 268,                  /* INSERT  */
+    DELETE = 269,                  /* DELETE  */
+    UPDATE = 270,                  /* UPDATE  */
+    LBRACE = 271,                  /* LBRACE  */
+    RBRACE = 272,                  /* RBRACE  */
+    COMMA = 273,                   /* COMMA  */
+    TRX_BEGIN = 274,               /* TRX_BEGIN  */
+    TRX_COMMIT = 275,              /* TRX_COMMIT  */
+    TRX_ROLLBACK = 276,            /* TRX_ROLLBACK  */
+    INT_T = 277,                   /* INT_T  */
+    STRING_T = 278,                /* STRING_T  */
+    FLOAT_T = 279,                 /* FLOAT_T  */
+    HELP = 280,                    /* HELP  */
+    EXIT = 281,                    /* EXIT  */
+    DOT = 282,                     /* DOT  */
+    INTO = 283,                    /* INTO  */
+    VALUES = 284,                  /* VALUES  */
+    FROM = 285,                    /* FROM  */
+    WHERE = 286,                   /* WHERE  */
+    AND = 287,                     /* AND  */
+    SET = 288,                     /* SET  */
+    ON = 289,                      /* ON  */
+    LOAD = 290,                    /* LOAD  */
+    DATA = 291,                    /* DATA  */
+    INFILE = 292,                  /* INFILE  */
+    EQ = 293,                      /* EQ  */
+    LT = 294,                      /* LT  */
+    GT = 295,                      /* GT  */
+    LE = 296,                      /* LE  */
+    GE = 297,                      /* GE  */
+    NE = 298,                      /* NE  */
+    NUMBER = 299,                  /* NUMBER  */
+    FLOAT = 300,                   /* FLOAT  */
+    ID = 301,                      /* ID  */
+    PATH = 302,                    /* PATH  */
+    SSS = 303,                     /* SSS  */
+    STAR = 304,                    /* STAR  */
+    STRING_V = 305                 /* STRING_V  */
   };
+  typedef enum yytokentype yytoken_kind_t;
 #endif
 
 /* Value type.  */
 #if ! defined YYSTYPE && ! defined YYSTYPE_IS_DECLARED
 union YYSTYPE
 {
-#line 118 "yacc_sql.y"
+#line 106 "yacc_sql.y"
 
   struct _Attr *attr;
   struct _Condition *condition1;
   struct _Value *value1;
-  char *datestr;
   char *string;
   int number;
   float floats;
 	char *position;
 
-#line 121 "yacc_sql.tab.h"
+#line 124 "yacc_sql.tab.h"
 
 };
 typedef union YYSTYPE YYSTYPE;
diff --git a/src/observer/sql/parser/yacc_sql.y b/src/observer/sql/parser/yacc_sql.y
index f37bd7f..dc8b901 100644
--- a/src/observer/sql/parser/yacc_sql.y
+++ b/src/observer/sql/parser/yacc_sql.y
@@ -4,7 +4,7 @@
 #include "sql/parser/parse_defs.h"
 #include "sql/parser/yacc_sql.tab.h"
 #include "sql/parser/lex.yy.h"
-//#include "common/log/log.h" // 包含C++中的头文件
+// #include "common/log/log.h" // 包含C++中的头文件
 
 #include<stdio.h>
 #include<stdlib.h>
@@ -46,17 +46,6 @@ void yyerror(yyscan_t scanner, const char *str)
   context->ssql->sstr.insertion.value_num = 0;
   printf("parse sql failed. error=%s", str);
 }
-void yyerror_date(yyscan_t scanner)
-{
-  ParserContext *context = (ParserContext *)(yyget_extra(scanner));
-  query_reset(context->ssql);
-  context->ssql->flag = SCF_DERROR;
-  context->condition_length = 0;
-  context->from_length = 0;
-  context->select_length = 0;
-  context->value_length = 0;
-  context->ssql->sstr.insertion.value_num = 0;
-}
 
 ParserContext *get_context(yyscan_t scanner)
 {
@@ -131,8 +120,8 @@ ParserContext *get_context(yyscan_t scanner)
 %token <string> ID
 %token <string> PATH
 %token <string> SSS
-%token <string> STAR
 %token <string> DATE;
+%token <string> STAR
 %token <string> STRING_V
 //非终结符
 
@@ -323,18 +312,15 @@ value:
     |FLOAT{
   		value_init_float(&CONTEXT->values[CONTEXT->value_length++], $1);
 		}
-	|DATE{
-		$1 = substr($1,1,strlen($1)-2);
-		value_init_date(&CONTEXT->values[CONTEXT->value_length++], $1);
-		//if(check_date(*(int *)(CONTEXT->values[CONTEXT->value_length].data))==0)
-		//	yyerror_date(scanner);
-	}
     |SSS {
-		$1 = substr($1,1,strlen($1)-2);
+			$1 = substr($1,1,strlen($1)-2);
   		value_init_string(&CONTEXT->values[CONTEXT->value_length++], $1);
-	}
-    ;
-    
+		}
+	|DATE{
+		    $1 = substr($1,1,strlen($1)-2);
+		value_init_date(&CONTEXT->values[CONTEXT->value_length++], $1);
+		}    
+    ;    
 delete:		/*  delete 语句的语法解析树*/
     DELETE FROM ID where SEMICOLON 
 		{
diff --git a/src/observer/sql/temp.cpp b/src/observer/sql/temp.cpp
deleted file mode 100644
index 02a03bc..0000000
--- a/src/observer/sql/temp.cpp
+++ /dev/null
@@ -1,20 +0,0 @@
-#include <stdio.h>
-#include <stdlib.h>
-#include <string.h>
-typedef struct _Date{
-  int year; //年
-  int month; //月
-  int datetime; //日
-} Date;
-
-bool check_date(Date *date){
-    int year = date->year;
-    int month = date->month;
-    int datetime = date->datetime;
-    int Month_buf[12] = { 31,28,31,30,31,30,31,31,30,31,30,31 };  //月份修正表
-    if(month==2)                                                             //闰年2月+1天
-        (((year%4==0)&&(year%100!=0))||(year%400==0))?Month_buf[1]+=1:Month_buf[1];
-    if (month>12||month<1||datetime>Month_buf[month-1]||datetime<1)           //判断月份日期是否合法
-        return false;
-    return true;
-}
diff --git a/src/observer/storage/common/bplus_tree.cpp b/src/observer/storage/common/bplus_tree.cpp
index c845e4c..fa9ef19 100644
--- a/src/observer/storage/common/bplus_tree.cpp
+++ b/src/observer/storage/common/bplus_tree.cpp
@@ -159,7 +159,7 @@ static int CmpRid(const RID *rid1, const RID *rid2) {
   return 0;
 }
 int CompareKey(const char *pdata, const char *pkey,AttrType attr_type,int attr_length) { // 简化
-  int i1,i2,d1,d2;
+  int i1,i2;
   float f1,f2;
   const char *s1,*s2;
   switch(attr_type){
@@ -197,6 +197,7 @@ int CompareKey(const char *pdata, const char *pkey,AttrType attr_type,int attr_l
       if (d1 == d2)
         return 0;
     }
+      break;
     default:{
       LOG_PANIC("Unknown attr type: %d", attr_type);
     }
diff --git a/src/observer/storage/common/condition_filter.cpp b/src/observer/storage/common/condition_filter.cpp
index 5beab5e..12014c9 100644
--- a/src/observer/storage/common/condition_filter.cpp
+++ b/src/observer/storage/common/condition_filter.cpp
@@ -56,11 +56,12 @@ RC DefaultConditionFilter::init(const ConDesc &left, const ConDesc &right, AttrT
   comp_op_ = comp_op;
   return RC::SUCCESS;
 }
+
 bool DefaultConditionFilter::check_date(int date){
   int year = date/10000;
   int month = date/100-year*100;
   int datetime = date-10000*year-100*month;
-	//LOG_INFO("The date is:%d,%d,%d",year,month,datetime);
+       //LOG_INFO("The date is:%d,%d,%d",year,month,datetime);
   int Month_buf[12] = { 31,28,31,30,31,30,31,31,30,31,30,31 };  //月份修正表
   if(month==2)                                                             //闰年2月+1天
     (((year%4==0)&&(year%100!=0))||(year%400==0))?Month_buf[1]+=1:Month_buf[1];
@@ -69,6 +70,85 @@ bool DefaultConditionFilter::check_date(int date){
   return true;
 }
 
+//新增的init重载函数，基本没变，只加了offset
+RC DefaultConditionFilter::init(Table *left_table, Table *right_table, const Condition& condition, int left_base_offset, int right_base_offset) {
+    
+    ConDesc left;
+    ConDesc right;
+
+    AttrType type_left = UNDEFINED;
+    AttrType type_right = UNDEFINED;
+
+    if (1 == condition.left_is_attr) {
+        if (left_table == nullptr) {
+            LOG_ERROR("an unexpected error\n");
+            return RC::GENERIC_ERROR;
+        }
+        const TableMeta& left_table_meta = left_table->table_meta();
+
+        left.is_attr = true;
+        const FieldMeta* field_left = left_table_meta.field(condition.left_attr.attribute_name);
+        if (nullptr == field_left) {
+            LOG_WARN("No such field in condition. %s.%s", left_table->name(), condition.left_attr.attribute_name);
+            return RC::SCHEMA_FIELD_MISSING;
+        }
+        left.attr_length = field_left->len();
+        left.attr_offset = field_left->offset() + left_base_offset;  //add offset
+
+        left.value = nullptr;
+
+        type_left = field_left->type();
+    }
+    else {
+        left.is_attr = false;
+        left.value = condition.left_value.data;  // 校验type 或者转换类型
+        type_left = condition.left_value.type;
+
+        left.attr_length = 0;
+        left.attr_offset = 0;
+    }
+
+    if (1 == condition.right_is_attr) {
+        if (right_table == nullptr) {
+            LOG_ERROR("an unexpected error\n");
+            return RC::GENERIC_ERROR;
+        }
+        const TableMeta& right_table_meta = right_table->table_meta();
+
+        right.is_attr = true;
+        const FieldMeta* field_right = right_table_meta.field(condition.right_attr.attribute_name);
+        if (nullptr == field_right) {
+            LOG_WARN("No such field in condition. %s.%s", right_table->name(), condition.right_attr.attribute_name);
+            return RC::SCHEMA_FIELD_MISSING;
+        }
+        right.attr_length = field_right->len();
+        right.attr_offset = field_right->offset() + right_base_offset;      //add offset
+        type_right = field_right->type();
+
+        right.value = nullptr;
+    }
+    else {
+        right.is_attr = false;
+        right.value = condition.right_value.data;
+        type_right = condition.right_value.type;
+
+        right.attr_length = 0;
+        right.attr_offset = 0;
+    }
+
+    // 校验和转换
+    //  if (!field_type_compare_compatible_table[type_left][type_right]) {
+    //    // 不能比较的两个字段， 要把信息传给客户端
+    //    return RC::SCHEMA_FIELD_TYPE_MISMATCH;
+    //  }
+    // NOTE：这里没有实现不同类型的数据比较，比如整数跟浮点数之间的对比
+    // 但是选手们还是要实现。这个功能在预选赛中会出现
+    if (type_left != type_right) {
+        return RC::SCHEMA_FIELD_TYPE_MISMATCH;
+    }
+
+    return init(left, right, type_left, condition.comp);
+}
 
 RC DefaultConditionFilter::init(Table &table, const Condition &condition)
 {
@@ -134,7 +214,6 @@ RC DefaultConditionFilter::init(Table &table, const Condition &condition)
   }
   // By:CAQ
   // 校验DATES类型的value是否合法
-  LOG_INFO("condition check date\n");
   if(left.is_attr == false && type_left == DATES){
     if(check_date(*(int *)(left.value))==false)
       return RC::INVALID_ARGUMENT;
@@ -143,6 +222,7 @@ RC DefaultConditionFilter::init(Table &table, const Condition &condition)
     if(check_date(*(int *)(right.value))==false)
       return RC::INVALID_ARGUMENT;
   }
+
   return init(left, right, type_left, condition.comp);
 }
 
@@ -185,7 +265,7 @@ bool DefaultConditionFilter::filter(const Record &rec) const
       int left = *(int *)left_value;
       int right = *(int *)right_value;
       cmp_result = left - right;
-    }break;
+    }break;   
     default: {
     }
   }
diff --git a/src/observer/storage/common/condition_filter.h b/src/observer/storage/common/condition_filter.h
index e80ccd5..27e5b74 100644
--- a/src/observer/storage/common/condition_filter.h
+++ b/src/observer/storage/common/condition_filter.h
@@ -48,9 +48,10 @@ public:
   RC init(const ConDesc &left, const ConDesc &right, AttrType attr_type, CompOp comp_op);
   RC init(Table &table, const Condition &condition);
 
-  virtual bool filter(const Record &rec) const;
+  //by XY:重载init函数for select-tables
+  RC init(Table *left_table, Table *right_table, const Condition& condition, int left_base_offset, int right_base_offset);
 
-  bool check_date(int date);
+  virtual bool filter(const Record &rec) const;
 
 public:
   const ConDesc &left() const {
diff --git a/src/observer/storage/common/db.cpp b/src/observer/storage/common/db.cpp
index d29bb5c..cb6a8ca 100644
--- a/src/observer/storage/common/db.cpp
+++ b/src/observer/storage/common/db.cpp
@@ -79,6 +79,13 @@ Table *Db::find_table(const char *table_name) const {
   return nullptr;
 }
 
+//add a fun:
+RC flush_opened_tables() {
+    
+    return RC::SUCCESS;
+}
+
+
 RC Db::open_all_tables() {
   std::vector<std::string> table_meta_files;
   int ret = common::list_file(path_.c_str(), TABLE_META_FILE_PATTERN, table_meta_files);
@@ -88,9 +95,11 @@ RC Db::open_all_tables() {
   }
 
   RC rc = RC::SUCCESS;
+  opened_tables_.clear(); ///add by xiayuan
   for (const std::string &filename : table_meta_files) {
     Table *table = new Table();
     rc = table->open(filename.c_str(), path_.c_str());
+    LOG_INFO("path=%s, filename=%s\n", path_.c_str(), filename.c_str());
     if (rc != RC::SUCCESS) {
       delete table;
       LOG_ERROR("Failed to open table. filename=%s", filename.c_str());
diff --git a/src/observer/storage/common/db.h b/src/observer/storage/common/db.h
index 588b3df..e633eff 100644
--- a/src/observer/storage/common/db.h
+++ b/src/observer/storage/common/db.h
@@ -40,7 +40,9 @@ public:
   void all_tables(std::vector<std::string> &table_names) const;
 
   RC sync();
-private:
+
+//private:
+//ıȨޣԵˢopened_tables_Դﵽdrop tableۼĿ
   RC open_all_tables();
 
 private:
diff --git a/src/observer/storage/common/field_meta.cpp b/src/observer/storage/common/field_meta.cpp
index 68837bf..431d8ee 100644
--- a/src/observer/storage/common/field_meta.cpp
+++ b/src/observer/storage/common/field_meta.cpp
@@ -61,7 +61,7 @@ RC FieldMeta::init(const char *name, AttrType attr_type, int attr_offset, int at
       name, attr_type, attr_offset, attr_len);
     return RC::INVALID_ARGUMENT;
   }
-  LOG_INFO("%s: %d",name,attr_type);
+
   name_ = name;
   attr_type_ = attr_type;
   attr_len_ = attr_len;
@@ -143,7 +143,6 @@ RC FieldMeta::from_json(const Json::Value &json_value, FieldMeta &field) {
   }
 
   AttrType type = attr_type_from_string(type_value.asCString());
-  LOG_INFO("type_value == %s\n",type_value.asCString());
   if (UNDEFINED == type) {
     LOG_ERROR("Got invalid field type. type=%d", type);
     return RC::GENERIC_ERROR;
diff --git a/src/observer/storage/common/record_manager.cpp b/src/observer/storage/common/record_manager.cpp
index 553de53..96ae86c 100644
--- a/src/observer/storage/common/record_manager.cpp
+++ b/src/observer/storage/common/record_manager.cpp
@@ -511,11 +511,11 @@ RC RecordFileScanner::get_next_record(Record *rec) {
     LOG_ERROR("Failed to get page count while getting next record. file id=%d", file_id_);
     return RC::RECORD_EOF;
   }
-  LOG_INFO("disk_buffer_pool_=%p, page_count=%d",disk_buffer_pool_,page_count);
+
   if (1 == page_count) {
     return RC::RECORD_EOF;
   }
-  LOG_INFO("current_record.rid.page_num=%d, page_count=%d",current_record.rid.page_num,page_count);
+
   while (current_record.rid.page_num < page_count) {
 
     if (current_record.rid.page_num != record_page_handler_.get_page_num()) {
diff --git a/src/observer/storage/common/table.cpp b/src/observer/storage/common/table.cpp
index 1a47971..98755c3 100644
--- a/src/observer/storage/common/table.cpp
+++ b/src/observer/storage/common/table.cpp
@@ -28,211 +28,211 @@ See the Mulan PSL v2 for more details. */
 #include "storage/common/bplus_tree_index.h"
 #include "storage/trx/trx.h"
 
-Table::Table() : 
+Table::Table() :
     data_buffer_pool_(nullptr),
     file_id_(-1),
     record_handler_(nullptr) {
 }
 
 Table::~Table() {
-  delete record_handler_;
-  record_handler_ = nullptr;
+    delete record_handler_;
+    record_handler_ = nullptr;
 
-  if (data_buffer_pool_ != nullptr && file_id_ >= 0) {
-    data_buffer_pool_->close_file(file_id_);
-    data_buffer_pool_ = nullptr;
-  }
+    if (data_buffer_pool_ != nullptr && file_id_ >= 0) {
+        data_buffer_pool_->close_file(file_id_);
+        data_buffer_pool_ = nullptr;
+    }
 
-  LOG_INFO("Table has been closed: %s", name());
+    LOG_INFO("Table has been closed: %s", name());
 }
 
-RC Table::create(const char *path, const char *name, const char *base_dir, int attribute_count, const AttrInfo attributes[]) {
+RC Table::create(const char* path, const char* name, const char* base_dir, int attribute_count, const AttrInfo attributes[]) {
 
-  if (nullptr == name || common::is_blank(name)) {
-    LOG_WARN("Name cannot be empty");
-    return RC::INVALID_ARGUMENT;
-  }
-  LOG_INFO("Begin to create table %s:%s", base_dir, name);
+    if (nullptr == name || common::is_blank(name)) {
+        LOG_WARN("Name cannot be empty");
+        return RC::INVALID_ARGUMENT;
+    }
+    LOG_INFO("Begin to create table %s:%s", base_dir, name);
 
-  if (attribute_count <= 0 || nullptr == attributes) {
-    LOG_WARN("Invalid arguments. table_name=%s, attribute_count=%d, attributes=%p",
-        name, attribute_count, attributes);
-    return RC::INVALID_ARGUMENT;
-  }
+    if (attribute_count <= 0 || nullptr == attributes) {
+        LOG_WARN("Invalid arguments. table_name=%s, attribute_count=%d, attributes=%p",
+            name, attribute_count, attributes);
+        return RC::INVALID_ARGUMENT;
+    }
 
-  RC rc = RC::SUCCESS;
+    RC rc = RC::SUCCESS;
 
-  // 使用 table_name.table记录一个表的元数据
-  // 判断表文件是否已经存在
+    // 使用 table_name.table记录一个表的元数据
+    // 判断表文件是否已经存在
 
-  int fd = ::open(path, O_WRONLY | O_CREAT | O_EXCL | O_CLOEXEC, 0600);
-  if (-1 == fd) {
-    if (EEXIST == errno) {
-      LOG_ERROR("Failed to create table file, it has been created. %s, EEXIST, %s",
+    int fd = ::open(path, O_WRONLY | O_CREAT | O_EXCL | O_CLOEXEC, 0600);
+    if (-1 == fd) {
+        if (EEXIST == errno) {
+            LOG_ERROR("Failed to create table file, it has been created. %s, EEXIST, %s",
                 path, strerror(errno));
-      return RC::SCHEMA_TABLE_EXIST;
+            return RC::SCHEMA_TABLE_EXIST;
+        }
+        LOG_ERROR("Create table file failed. filename=%s, errmsg=%d:%s",
+            path, errno, strerror(errno));
+        return RC::IOERR;
     }
-    LOG_ERROR("Create table file failed. filename=%s, errmsg=%d:%s", 
-       path, errno, strerror(errno));
-    return RC::IOERR;
-  }
 
-  close(fd);
+    close(fd);
 
-  // 创建文件
-  if ((rc = table_meta_.init(name, attribute_count, attributes)) != RC::SUCCESS) {
-    LOG_ERROR("Failed to init table meta. name:%s, ret:%d", name, rc);
-    return rc; // delete table file
-  }
+    // 创建文件
+    if ((rc = table_meta_.init(name, attribute_count, attributes)) != RC::SUCCESS) {
+        LOG_ERROR("Failed to init table meta. name:%s, ret:%d", name, rc);
+        return rc; // delete table file
+    }
 
-  std::fstream fs;
-  fs.open(path, std::ios_base::out | std::ios_base::binary);
-  if (!fs.is_open()) {
-    LOG_ERROR("Failed to open file for write. file name=%s, errmsg=%s", path, strerror(errno));
-    return RC::IOERR;
-  }
+    std::fstream fs;
+    fs.open(path, std::ios_base::out | std::ios_base::binary);
+    if (!fs.is_open()) {
+        LOG_ERROR("Failed to open file for write. file name=%s, errmsg=%s", path, strerror(errno));
+        return RC::IOERR;
+    }
 
-  // 记录元数据到文件中
-  table_meta_.serialize(fs);
-  fs.close();
+    // 记录元数据到文件中
+    table_meta_.serialize(fs);
+    fs.close();
 
-  std::string data_file = std::string(base_dir) + "/" + name + TABLE_DATA_SUFFIX;
-  data_buffer_pool_ = theGlobalDiskBufferPool();
-  rc = data_buffer_pool_->create_file(data_file.c_str());
-  if (rc != RC::SUCCESS) {
-    LOG_ERROR("Failed to create disk buffer pool of data file. file name=%s", data_file.c_str());
-    return rc;
-  }
+    std::string data_file = std::string(base_dir) + "/" + name + TABLE_DATA_SUFFIX;
+    data_buffer_pool_ = theGlobalDiskBufferPool();
+    rc = data_buffer_pool_->create_file(data_file.c_str());
+    if (rc != RC::SUCCESS) {
+        LOG_ERROR("Failed to create disk buffer pool of data file. file name=%s", data_file.c_str());
+        return rc;
+    }
 
-  rc = init_record_handler(base_dir);
+    rc = init_record_handler(base_dir);
 
-  base_dir_ = base_dir;
-  LOG_INFO("Successfully create table %s:%s", base_dir, name);
-  return rc;
+    base_dir_ = base_dir;
+    LOG_INFO("Successfully create table %s:%s", base_dir, name);
+    return rc;
 }
 
-RC Table::open(const char *meta_file, const char *base_dir) {
-  // 加载元数据文件
-  std::fstream fs;
-  std::string meta_file_path = std::string(base_dir) + "/" + meta_file;
-  fs.open(meta_file_path, std::ios_base::in | std::ios_base::binary);
-  if (!fs.is_open()) {
-    LOG_ERROR("Failed to open meta file for read. file name=%s, errmsg=%s", meta_file, strerror(errno));
-    return RC::IOERR;
-  }
-  if (table_meta_.deserialize(fs) < 0) {
-    LOG_ERROR("Failed to deserialize table meta. file name=%s", meta_file);
-    return RC::GENERIC_ERROR;
-  }
-  fs.close();
+RC Table::open(const char* meta_file, const char* base_dir) {
+    // 加载元数据文件
+    std::fstream fs;
+    std::string meta_file_path = std::string(base_dir) + "/" + meta_file;
+    fs.open(meta_file_path, std::ios_base::in | std::ios_base::binary);
+    if (!fs.is_open()) {
+        LOG_ERROR("Failed to open meta file for read. file name=%s, errmsg=%s", meta_file, strerror(errno));
+        return RC::IOERR;
+    }
+    if (table_meta_.deserialize(fs) < 0) {
+        LOG_ERROR("Failed to deserialize table meta. file name=%s", meta_file);
+        return RC::GENERIC_ERROR;
+    }
+    fs.close();
 
-  // 加载数据文件
-  RC rc = init_record_handler(base_dir);
+    // 加载数据文件
+    RC rc = init_record_handler(base_dir);
 
-  base_dir_ = base_dir;
+    base_dir_ = base_dir;
 
-  const int index_num = table_meta_.index_num();
-  for (int i = 0; i < index_num; i++) {
-    const IndexMeta *index_meta = table_meta_.index(i);
-    const FieldMeta *field_meta = table_meta_.field(index_meta->field());
-    if (field_meta == nullptr) {
-      LOG_PANIC("Found invalid index meta info which has a non-exists field. table=%s, index=%s, field=%s",
+    const int index_num = table_meta_.index_num();
+    for (int i = 0; i < index_num; i++) {
+        const IndexMeta* index_meta = table_meta_.index(i);
+        const FieldMeta* field_meta = table_meta_.field(index_meta->field());
+        if (field_meta == nullptr) {
+            LOG_PANIC("Found invalid index meta info which has a non-exists field. table=%s, index=%s, field=%s",
                 name(), index_meta->name(), index_meta->field());
-      return RC::GENERIC_ERROR;
-    }
-
-    BplusTreeIndex *index = new BplusTreeIndex();
-    std::string index_file = index_data_file(base_dir, name(), index_meta->name());
-    rc = index->open(index_file.c_str(), *index_meta, *field_meta);
-    if (rc != RC::SUCCESS) {
-      delete index;
-      LOG_ERROR("Failed to open index. table=%s, index=%s, file=%s, rc=%d:%s",
+            return RC::GENERIC_ERROR;
+        }
+
+        BplusTreeIndex* index = new BplusTreeIndex();
+        std::string index_file = index_data_file(base_dir, name(), index_meta->name());
+        rc = index->open(index_file.c_str(), *index_meta, *field_meta);
+        if (rc != RC::SUCCESS) {
+            delete index;
+            LOG_ERROR("Failed to open index. table=%s, index=%s, file=%s, rc=%d:%s",
                 name(), index_meta->name(), index_file.c_str(), rc, strrc(rc));
-      return rc;
+            return rc;
+        }
+        indexes_.push_back(index);
     }
-    indexes_.push_back(index);
-  }
-  return rc;
+    return rc;
 }
 
-RC Table::commit_insert(Trx *trx, const RID &rid) {
-  Record record;
-  RC rc = record_handler_->get_record(&rid, &record);
-  if (rc != RC::SUCCESS) {
-    return rc;
-  }
+RC Table::commit_insert(Trx* trx, const RID& rid) {
+    Record record;
+    RC rc = record_handler_->get_record(&rid, &record);
+    if (rc != RC::SUCCESS) {
+        return rc;
+    }
 
-  return trx->commit_insert(this, record);
+    return trx->commit_insert(this, record);
 }
 
-RC Table::rollback_insert(Trx *trx, const RID &rid) {
+RC Table::rollback_insert(Trx* trx, const RID& rid) {
 
-  Record record;
-  RC rc = record_handler_->get_record(&rid, &record);
-  if (rc != RC::SUCCESS) {
-    return rc;
-  }
+    Record record;
+    RC rc = record_handler_->get_record(&rid, &record);
+    if (rc != RC::SUCCESS) {
+        return rc;
+    }
 
-  // remove all indexes
-  rc = delete_entry_of_indexes(record.data, rid, false);
-  if (rc != RC::SUCCESS) {
-    LOG_ERROR("Failed to delete indexes of record(rid=%d.%d) while rollback insert, rc=%d:%s",
-              rid.page_num, rid.slot_num, rc, strrc(rc));
-  } else {
-    rc = record_handler_->delete_record(&rid);
-  }
-  return rc;
+    // remove all indexes
+    rc = delete_entry_of_indexes(record.data, rid, false);
+    if (rc != RC::SUCCESS) {
+        LOG_ERROR("Failed to delete indexes of record(rid=%d.%d) while rollback insert, rc=%d:%s",
+            rid.page_num, rid.slot_num, rc, strrc(rc));
+    }
+    else {
+        rc = record_handler_->delete_record(&rid);
+    }
+    return rc;
 }
 
-RC Table::insert_record(Trx *trx, Record *record) {
-  RC rc = RC::SUCCESS;
-
-  if (trx != nullptr) {
-    trx->init_trx_info(this, *record);
-  }
-  rc = record_handler_->insert_record(record->data, table_meta_.record_size(), &record->rid);
-  if (rc != RC::SUCCESS) {
-    LOG_ERROR("Insert record failed. table name=%s, rc=%d:%s", table_meta_.name(), rc, strrc(rc));
-    return rc;
-  }
+RC Table::insert_record(Trx* trx, Record* record) {
+    RC rc = RC::SUCCESS;
 
-  if (trx != nullptr) {
-    rc = trx->insert_record(this, record);
+    if (trx != nullptr) {
+        trx->init_trx_info(this, *record);
+    }
+    rc = record_handler_->insert_record(record->data, table_meta_.record_size(), &record->rid);
     if (rc != RC::SUCCESS) {
-      LOG_ERROR("Failed to log operation(insertion) to trx");
+        LOG_ERROR("Insert record failed. table name=%s, rc=%d:%s", table_meta_.name(), rc, strrc(rc));
+        return rc;
+    }
 
-      RC rc2 = record_handler_->delete_record(&record->rid);
-      if (rc2 != RC::SUCCESS) {
-        LOG_PANIC("Failed to rollback record data when insert index entries failed. table name=%s, rc=%d:%s",
-                  name(), rc2, strrc(rc2));
-      }
-      return rc;
+    if (trx != nullptr) {
+        rc = trx->insert_record(this, record);
+        if (rc != RC::SUCCESS) {
+            LOG_ERROR("Failed to log operation(insertion) to trx");
+
+            RC rc2 = record_handler_->delete_record(&record->rid);
+            if (rc2 != RC::SUCCESS) {
+                LOG_PANIC("Failed to rollback record data when insert index entries failed. table name=%s, rc=%d:%s",
+                    name(), rc2, strrc(rc2));
+            }
+            return rc;
+        }
     }
-  }
 
-  rc = insert_entry_of_indexes(record->data, record->rid);
-  if (rc != RC::SUCCESS) {
-    RC rc2 = delete_entry_of_indexes(record->data, record->rid, true);
-    if (rc2 != RC::SUCCESS) {
-      LOG_PANIC("Failed to rollback index data when insert index entries failed. table name=%s, rc=%d:%s",
+    rc = insert_entry_of_indexes(record->data, record->rid);
+    if (rc != RC::SUCCESS) {
+        RC rc2 = delete_entry_of_indexes(record->data, record->rid, true);
+        if (rc2 != RC::SUCCESS) {
+            LOG_PANIC("Failed to rollback index data when insert index entries failed. table name=%s, rc=%d:%s",
                 name(), rc2, strrc(rc2));
-    }
-    rc2 = record_handler_->delete_record(&record->rid);
-    if (rc2 != RC::SUCCESS) {
-      LOG_PANIC("Failed to rollback record data when insert index entries failed. table name=%s, rc=%d:%s",
+        }
+        rc2 = record_handler_->delete_record(&record->rid);
+        if (rc2 != RC::SUCCESS) {
+            LOG_PANIC("Failed to rollback record data when insert index entries failed. table name=%s, rc=%d:%s",
                 name(), rc2, strrc(rc2));
+        }
+        return rc;
     }
     return rc;
-  }
-  return rc;
 }
-
 bool Table::check_date(const Value value){
   int date = *(int *)value.data;
   int year = date/10000;
   int month = date/100-year*100;
   int datetime = date-10000*year-100*month;
-	//LOG_INFO("The date is:%d,%d,%d",year,month,datetime);
+       //LOG_INFO("The date is:%d,%d,%d",year,month,datetime);
   int Month_buf[12] = { 31,28,31,30,31,30,31,31,30,31,30,31 };  //月份修正表
   if(month==2)                                                             //闰年2月+1天
     (((year%4==0)&&(year%100!=0))||(year%400==0))?Month_buf[1]+=1:Month_buf[1];
@@ -241,99 +241,89 @@ bool Table::check_date(const Value value){
   return true;
 }
 
-RC Table::insert_record(Trx *trx, int value_num, const Value *values) {
-  if (value_num <= 0 || nullptr == values ) {
-    LOG_ERROR("Invalid argument. value num=%d, values=%p", value_num, values);
-    return RC::INVALID_ARGUMENT;
-  }
-  /*BY:CAQ 遍历values,查找type是DATES的value，进行value验证*/
-  int i;
-  for(i=0;i<value_num;i++){
-    const Value &value = values[i];
-    if(value.type == DATES){
-      if(check_date(value)==false)
+RC Table::insert_record(Trx* trx, int value_num, const Value* values) {
+    if (value_num <= 0 || nullptr == values) {
+        LOG_ERROR("Invalid argument. value num=%d, values=%p", value_num, values);
         return RC::INVALID_ARGUMENT;
     }
-  }
-  char *record_data;
-  RC rc = make_record(value_num, values, record_data);
-  if (rc != RC::SUCCESS) {
-    LOG_ERROR("Failed to create a record. rc=%d:%s", rc, strrc(rc));
-    return rc;
-  }
 
-  Record record;
-  record.data = record_data;
-  // record.valid = true;
-  rc = insert_record(trx, &record);
-  delete[] record_data;
-  return rc;
+    char* record_data;
+    RC rc = make_record(value_num, values, record_data);
+    if (rc != RC::SUCCESS) {
+        LOG_ERROR("Failed to create a record. rc=%d:%s", rc, strrc(rc));
+        return rc;
+    }
+
+    Record record;
+    record.data = record_data;
+    // record.valid = true;
+    rc = insert_record(trx, &record);
+    delete[] record_data;
+    return rc;
 }
 
-const char *Table::name() const {
-  return table_meta_.name();
+const char* Table::name() const {
+    return table_meta_.name();
 }
 
-const TableMeta &Table::table_meta() const {
-  return table_meta_;
+const TableMeta& Table::table_meta() const {
+    return table_meta_;
 }
 
-RC Table::make_record(int value_num, const Value *values, char * &record_out) {
-  // 检查字段数量和类型是否一致
-  if (value_num + table_meta_.sys_field_num() != table_meta_.field_num()) {
-    return RC::SCHEMA_FIELD_MISSING;
-  }
+RC Table::make_record(int value_num, const Value* values, char*& record_out) {
+    // 检查字段类型是否一致
+    if (value_num + table_meta_.sys_field_num() != table_meta_.field_num()) {
+        return RC::SCHEMA_FIELD_MISSING;
+    }
 
-  const int normal_field_start_index = table_meta_.sys_field_num();
-  for (int i = 0; i < value_num; i++) {
-    const FieldMeta *field = table_meta_.field(i + normal_field_start_index);
-    const Value &value = values[i];
-    if (field->type() != value.type) {
-      LOG_ERROR("Invalid value type. field name=%s, type=%d, but given=%d",
-        field->name(), field->type(), value.type);
-      return RC::SCHEMA_FIELD_TYPE_MISMATCH;
+    const int normal_field_start_index = table_meta_.sys_field_num();
+    for (int i = 0; i < value_num; i++) {
+        const FieldMeta* field = table_meta_.field(i + normal_field_start_index);
+        const Value& value = values[i];
+        if (field->type() != value.type) {
+            LOG_ERROR("Invalid value type. field name=%s, type=%d, but given=%d",
+                field->name(), field->type(), value.type);
+            return RC::SCHEMA_FIELD_TYPE_MISMATCH;
+        }
     }
-  }
-  //LOG_INFO("Begin to copy the data!\n");
-  // 复制所有字段的值
-  int record_size = table_meta_.record_size();
-  char *record = new char [record_size];
-  LOG_INFO("The value num is %d!\n",value_num);
-  for (int i = 0; i < value_num; i++) {
-    const FieldMeta *field = table_meta_.field(i + normal_field_start_index);
-    const Value &value = values[i];
-    //if(value.type==CHARS)
-      //LOG_INFO("Store the the len \"%d\" \"%s\" at field.offset:%d\n",field->len(),value.data,(char *)field->offset());
-    memcpy(record + field->offset(), value.data, field->len());
-  }
 
-  record_out = record;
-  return RC::SUCCESS;
+    // 复制所有字段的值
+    int record_size = table_meta_.record_size();
+    char* record = new char[record_size];
+
+    for (int i = 0; i < value_num; i++) {
+        const FieldMeta* field = table_meta_.field(i + normal_field_start_index);
+        const Value& value = values[i];
+        memcpy(record + field->offset(), value.data, field->len());
+    }
+
+    record_out = record;
+    return RC::SUCCESS;
 }
 
-RC Table::init_record_handler(const char *base_dir) {
-  std::string data_file = std::string(base_dir) + "/" + table_meta_.name() + TABLE_DATA_SUFFIX;
-  if (nullptr == data_buffer_pool_) {
-    data_buffer_pool_ = theGlobalDiskBufferPool();
-  }
+RC Table::init_record_handler(const char* base_dir) {
+    std::string data_file = std::string(base_dir) + "/" + table_meta_.name() + TABLE_DATA_SUFFIX;
+    if (nullptr == data_buffer_pool_) {
+        data_buffer_pool_ = theGlobalDiskBufferPool();
+    }
 
-  int data_buffer_pool_file_id;
-  RC rc = data_buffer_pool_->open_file(data_file.c_str(), &data_buffer_pool_file_id);
-  if (rc != RC::SUCCESS) {
-    LOG_ERROR("Failed to open disk buffer pool for file:%s. rc=%d:%s",
-              data_file.c_str(), rc, strrc(rc));
-    return rc;
-  }
+    int data_buffer_pool_file_id;
+    RC rc = data_buffer_pool_->open_file(data_file.c_str(), &data_buffer_pool_file_id);
+    if (rc != RC::SUCCESS) {
+        LOG_ERROR("Failed to open disk buffer pool for file:%s. rc=%d:%s",
+            data_file.c_str(), rc, strrc(rc));
+        return rc;
+    }
 
-  record_handler_ = new RecordFileHandler();
-  rc = record_handler_->init(*data_buffer_pool_, data_buffer_pool_file_id);
-  if (rc != RC::SUCCESS) {
-    LOG_ERROR("Failed to init record handler. rc=%d:%s", rc, strrc(rc));
-    return rc;
-  }
+    record_handler_ = new RecordFileHandler();
+    rc = record_handler_->init(*data_buffer_pool_, data_buffer_pool_file_id);
+    if (rc != RC::SUCCESS) {
+        LOG_ERROR("Failed to init record handler. rc=%d:%s", rc, strrc(rc));
+        return rc;
+    }
 
-  file_id_ = data_buffer_pool_file_id;
-  return rc;
+    file_id_ = data_buffer_pool_file_id;
+    return rc;
 }
 
 /**
@@ -341,26 +331,26 @@ RC Table::init_record_handler(const char *base_dir) {
  */
 class RecordReaderScanAdapter {
 public:
-  explicit RecordReaderScanAdapter(void (*record_reader)(const char *data, void *context), void *context)
-      : record_reader_(record_reader), context_(context){
-  }
+    explicit RecordReaderScanAdapter(void (*record_reader)(const char* data, void* context), void* context)
+        : record_reader_(record_reader), context_(context) {
+    }
 
-  void consume(const Record *record) {
-    record_reader_(record->data, context_);
-  }
+    void consume(const Record* record) {
+        record_reader_(record->data, context_);
+    }
 private:
-  void (*record_reader_)(const char *, void *);
-  void *context_;
+    void (*record_reader_)(const char*, void*);
+    void* context_;
 };
-static RC scan_record_reader_adapter(Record *record, void *context) {
-  RecordReaderScanAdapter &adapter = *(RecordReaderScanAdapter *)context;
-  adapter.consume(record);
-  return RC::SUCCESS;
+static RC scan_record_reader_adapter(Record* record, void* context) {
+    RecordReaderScanAdapter& adapter = *(RecordReaderScanAdapter*)context;
+    adapter.consume(record);
+    return RC::SUCCESS;
 }
 
-RC Table::scan_record(Trx *trx, ConditionFilter *filter, int limit, void *context, void (*record_reader)(const char *data, void *context)) {
-  RecordReaderScanAdapter adapter(record_reader, context);
-  return scan_record(trx, filter, limit, (void *)&adapter, scan_record_reader_adapter);
+RC Table::scan_record(Trx* trx, ConditionFilter* filter, int limit, void* context, void (*record_reader)(const char* data, void* context)) {
+    RecordReaderScanAdapter adapter(record_reader, context);
+    return scan_record(trx, filter, limit, (void*)&adapter, scan_record_reader_adapter);
 }
 
 RC Table::scan_record(Trx *trx, ConditionFilter *filter, int limit, std::vector<RID >& ridlist){
@@ -495,59 +485,142 @@ RC Table::scan_record_by_index(Trx *trx, IndexScanner *scanner, ConditionFilter
   return rc;
 }
 
-RC Table::scan_record_by_index(Trx *trx, IndexScanner *scanner, ConditionFilter *filter, int limit, void *context,
-                               RC (*record_reader)(Record *, void *)) {
-  RC rc = RC::SUCCESS;
-  RID rid;
-  Record record;
-  int record_count = 0;
-  while (record_count < limit) {
-    rc = scanner->next_entry(&rid);
-    if (rc != RC::SUCCESS) {
-      if (RC::RECORD_EOF == rc) {
-        rc = RC::SUCCESS;
-        break;
-      }
-      LOG_ERROR("Failed to scan table by index. rc=%d:%s", rc, strrc(rc));
-      break;
-    }
-
-    rc = record_handler_->get_record(&rid, &record);
-    if (rc != RC::SUCCESS) {
-      LOG_ERROR("Failed to fetch record of rid=%d:%d, rc=%d:%s", rid.page_num, rid.slot_num, rc, strrc(rc));
-      break;
-    }
 
-    if ((trx == nullptr || trx->is_visible(this, &record)) && (filter == nullptr || filter->filter(record))) {
-      rc = record_reader(&record, context);
-      if (rc != RC::SUCCESS) {
-        LOG_TRACE("Record reader break the table scanning. rc=%d:%s", rc, strrc(rc));
-        break;
-      }
+RC Table::scan_record_by_index(Trx* trx, IndexScanner* scanner, ConditionFilter* filter, int limit, void* context,
+    RC(*record_reader)(Record*, void*)) {
+    RC rc = RC::SUCCESS;
+    RID rid;
+    Record record;
+    int record_count = 0;
+    while (record_count < limit) {
+        rc = scanner->next_entry(&rid);
+        if (rc != RC::SUCCESS) {
+            if (RC::RECORD_EOF == rc) {
+                rc = RC::SUCCESS;
+                break;
+            }
+            LOG_ERROR("Failed to scan table by index. rc=%d:%s", rc, strrc(rc));
+            break;
+        }
+
+        rc = record_handler_->get_record(&rid, &record);
+        if (rc != RC::SUCCESS) {
+            LOG_ERROR("Failed to fetch record of rid=%d:%d, rc=%d:%s", rid.page_num, rid.slot_num, rc, strrc(rc));
+            break;
+        }
+
+        if ((trx == nullptr || trx->is_visible(this, &record)) && (filter == nullptr || filter->filter(record))) {
+            rc = record_reader(&record, context);
+            if (rc != RC::SUCCESS) {
+                LOG_TRACE("Record reader break the table scanning. rc=%d:%s", rc, strrc(rc));
+                break;
+            }
+        }
+
+        record_count++;
     }
 
-    record_count++;
-  }
-
-  scanner->destroy();
-  return rc;
+    scanner->destroy();
+    return rc;
 }
 
 class IndexInserter {
 public:
-  explicit IndexInserter(Index *index) : index_(index) {
-  }
+    explicit IndexInserter(Index* index) : index_(index) {
+    }
 
-  RC insert_index(const Record *record) {
-    return index_->insert_entry(record->data, &record->rid);
-  }
+    RC insert_index(const Record* record) {
+        return index_->insert_entry(record->data, &record->rid);
+    }
 private:
-  Index * index_;
+    Index* index_;
 };
 
-static RC insert_index_record_reader_adapter(Record *record, void *context) {
-  IndexInserter &inserter = *(IndexInserter *)context;
-  return inserter.insert_index(record);
+static RC insert_index_record_reader_adapter(Record* record, void* context) {
+    IndexInserter& inserter = *(IndexInserter*)context;
+    return inserter.insert_index(record);
+}
+
+RC Table::update_index(Trx* trx, const char* attribute_name) {
+    RC rc = RC::SUCCESS;
+    const IndexMeta* index_meta = table_meta_.find_index_by_field(attribute_name);
+    if (index_meta == nullptr) {    //不是索引
+        return RC::SUCCESS;
+    }
+    const char* index_name = index_meta->name();
+    Index* old_index = find_index(index_name);
+    if (old_index == nullptr) {
+        return RC::SUCCESS;
+    }
+    std::vector<Index*>::iterator it = std::find(indexes_.begin(), indexes_.end(), old_index);
+    if (it == indexes_.end()) {
+        LOG_INFO("an unexpected error!\n");
+        return RC::SUCCESS;
+    }
+    indexes_.erase(it);
+    delete old_index;
+
+    //删除原来的.index文件
+    std::string relation_name_str = table_meta_.name();
+    std::string indexfile_name = relation_name_str + "-";
+    indexfile_name += index_name;
+    indexfile_name += ".index";
+    std::string index_path = "./miniob/db/sys/" + indexfile_name;
+    if (remove(index_path.c_str()) != 0) {  //删除失败
+        LOG_ERROR("Failed to delete .index file: %s\n", index_path.c_str());
+        return RC::GENERIC_ERROR;
+    }
+
+    // 重新创建索引相关数据，建立.index文件
+    const FieldMeta* field_meta = table_meta_.field(attribute_name);
+    BplusTreeIndex* index = new BplusTreeIndex();
+    std::string index_file = index_data_file(base_dir_.c_str(), name(), index_name);
+    rc = index->create(index_file.c_str(), *index_meta, *field_meta);
+    if (rc != RC::SUCCESS) {
+        delete index;
+        LOG_ERROR("Failed to create bplus tree index. file name=%s, rc=%d:%s", index_file.c_str(), rc, strrc(rc));
+        return rc;
+    }
+
+    // 重新遍历当前的所有数据，插入这个索引
+    IndexInserter index_inserter(index);
+    rc = scan_record(trx, nullptr, -1, &index_inserter, insert_index_record_reader_adapter);
+    if (rc != RC::SUCCESS) {
+        // rollback
+        delete index;
+        LOG_ERROR("Failed to insert index to all records. table=%s, rc=%d:%s", name(), rc, strrc(rc));
+        return rc;
+    }
+    indexes_.push_back(index);
+
+
+    // 创建元数据临时文件
+    std::string tmp_file = table_meta_file(base_dir_.c_str(), name()) + ".tmp";
+    std::fstream fs;
+    fs.open(tmp_file, std::ios_base::out | std::ios_base::binary | std::ios_base::trunc);
+    if (!fs.is_open()) {
+        LOG_ERROR("Failed to open file for write. file name=%s, errmsg=%s", tmp_file.c_str(), strerror(errno));
+        return RC::IOERR; // 创建索引中途出错，要做还原操作
+    }
+    if (table_meta_.serialize(fs) < 0) {
+        LOG_ERROR("Failed to dump new table meta to file: %s. sys err=%d:%s", tmp_file.c_str(), errno, strerror(errno));
+        return RC::IOERR;
+    }
+    fs.close();
+
+    // 覆盖原始元数据文件
+    std::string meta_file = table_meta_file(base_dir_.c_str(), name());
+    int ret = rename(tmp_file.c_str(), meta_file.c_str());
+    if (ret != 0) {
+        LOG_ERROR("Failed to rename tmp meta file (%s) to normal meta file (%s) while creating index (%s) on table (%s). " \
+            "system error=%d:%s", tmp_file.c_str(), meta_file.c_str(), index_name, name(), errno, strerror(errno));
+        return RC::IOERR;
+    }
+
+
+    LOG_INFO("add a new index (%s) on the table (%s)", index_name, name());
+
+    return rc;
 }
 
 RC Table::create_index(Trx *trx, const char *index_name, const char *attribute_name) {
@@ -628,6 +701,7 @@ RC Table::create_index(Trx *trx, const char *index_name, const char *attribute_n
   return rc;
 }
 
+
 /*by CAQ*/
 RC Table::update_record(Trx *trx, const char *attribute_name, const Value *value, int condition_num, const Condition conditions[], int *updated_count) {
   RC rc = RC::SUCCESS;
@@ -638,17 +712,11 @@ RC Table::update_record(Trx *trx, const char *attribute_name, const Value *value
     return RC::SCHEMA_FIELD_MISSING;
   }
   //检查attribute字段类型是否相同
-  if(field_meta->type() != value->type){
+  else if(field_meta->type() != value->type){
     LOG_ERROR("Invalid value type. field name=%s, type=%d, but given=%d",
     field_meta->name(), field_meta->type(), value->type);
     return RC::SCHEMA_FIELD_TYPE_MISMATCH;
   }
-  //如果value是DATES，需要检查合法性
-  if(value->type==DATES){
-    if(check_date(*value)==false){
-      return RC::INVALID_ARGUMENT;
-    }
-  }
   //获得偏移量和value长度
   int attr_offset = field_meta->offset();
   int attr_len = field_meta->len();
@@ -692,6 +760,12 @@ RC Table::update_record(Trx *trx, const char *attribute_name, const Value *value
     }
     LOG_INFO("Insert the new record!");
   }
+
+  //by XY: update index
+  if (update_index(trx, attribute_name) != RC::SUCCESS) {
+      LOG_ERROR("failed to update index\n");
+      return RC::GENERIC_ERROR;
+  }
   return rc;
 }
 /*
@@ -728,196 +802,199 @@ RC Table::update_record(Trx *trx, int attr_offset, int attr_len, const Value *va
 
 class RecordDeleter {
 public:
-  RecordDeleter(Table &table, Trx *trx) : table_(table), trx_(trx) {
-  }
+    RecordDeleter(Table& table, Trx* trx) : table_(table), trx_(trx) {
+    }
 
-  RC delete_record(Record *record) {
-    RC rc = RC::SUCCESS;
-    rc = table_.delete_record(trx_, record);
-    if (rc == RC::SUCCESS) {
-      deleted_count_++;
+    RC delete_record(Record* record) {
+        RC rc = RC::SUCCESS;
+        rc = table_.delete_record(trx_, record);
+        if (rc == RC::SUCCESS) {
+            deleted_count_++;
+        }
+        return rc;
     }
-    return rc;
-  }
 
-  int deleted_count() const {
-    return deleted_count_;
-  }
+    int deleted_count() const {
+        return deleted_count_;
+    }
 
 private:
-  Table & table_;
-  Trx *trx_;
-  int deleted_count_ = 0;
+    Table& table_;
+    Trx* trx_;
+    int deleted_count_ = 0;
 };
 
-static RC record_reader_delete_adapter(Record *record, void *context) {
-  RecordDeleter &record_deleter = *(RecordDeleter *)context;
-  return record_deleter.delete_record(record);
+static RC record_reader_delete_adapter(Record* record, void* context) {
+    RecordDeleter& record_deleter = *(RecordDeleter*)context;
+    return record_deleter.delete_record(record);
 }
 
-RC Table::delete_record(Trx *trx, ConditionFilter *filter, int *deleted_count) {
-  RecordDeleter deleter(*this, trx);
-  RC rc = scan_record(trx, filter, -1, &deleter, record_reader_delete_adapter);
-  if (deleted_count != nullptr) {
-    *deleted_count = deleter.deleted_count();
-  }
-  return rc;
+RC Table::delete_record(Trx* trx, ConditionFilter* filter, int* deleted_count) {
+    RecordDeleter deleter(*this, trx);
+    RC rc = scan_record(trx, filter, -1, &deleter, record_reader_delete_adapter);
+    if (deleted_count != nullptr) {
+        *deleted_count = deleter.deleted_count();
+    }
+    return rc;
 }
 
-RC Table::delete_record(Trx *trx, Record *record) {
-  RC rc = RC::SUCCESS;
-  if (trx != nullptr) {
-    rc = trx->delete_record(this, record);
-  } else {
-    rc = delete_entry_of_indexes(record->data, record->rid, false);// 重复代码 refer to commit_delete
-    if (rc != RC::SUCCESS) {
-      LOG_ERROR("Failed to delete indexes of record (rid=%d.%d). rc=%d:%s",
+RC Table::delete_record(Trx* trx, Record* record) {
+    RC rc = RC::SUCCESS;
+    if (trx != nullptr) {
+        rc = trx->delete_record(this, record);
+    }
+    else {
+        rc = delete_entry_of_indexes(record->data, record->rid, false);// 重复代码 refer to commit_delete
+        if (rc != RC::SUCCESS) {
+            LOG_ERROR("Failed to delete indexes of record (rid=%d.%d). rc=%d:%s",
                 record->rid.page_num, record->rid.slot_num, rc, strrc(rc));
-    } else {
-      rc = record_handler_->delete_record(&record->rid);
+        }
+        else {
+            rc = record_handler_->delete_record(&record->rid);
+        }
     }
-  }
-  return rc;
+    return rc;
 }
 
-RC Table::commit_delete(Trx *trx, const RID &rid) {
-  RC rc = RC::SUCCESS;
-  Record record;
-  rc = record_handler_->get_record(&rid, &record);
-  if (rc != RC::SUCCESS) {
-    return rc;
-  }
-  rc = delete_entry_of_indexes(record.data, record.rid, false);
-  if (rc != RC::SUCCESS) {
-    LOG_ERROR("Failed to delete indexes of record(rid=%d.%d). rc=%d:%s",
-              rid.page_num, rid.slot_num, rc, strrc(rc));// panic?
-  }
+RC Table::commit_delete(Trx* trx, const RID& rid) {
+    RC rc = RC::SUCCESS;
+    Record record;
+    rc = record_handler_->get_record(&rid, &record);
+    if (rc != RC::SUCCESS) {
+        return rc;
+    }
+    rc = delete_entry_of_indexes(record.data, record.rid, false);
+    if (rc != RC::SUCCESS) {
+        LOG_ERROR("Failed to delete indexes of record(rid=%d.%d). rc=%d:%s",
+            rid.page_num, rid.slot_num, rc, strrc(rc));// panic?
+    }
 
-  rc = record_handler_->delete_record(&rid);
-  if (rc != RC::SUCCESS) {
-    return rc;
-  }
+    rc = record_handler_->delete_record(&rid);
+    if (rc != RC::SUCCESS) {
+        return rc;
+    }
 
-  return rc;
+    return rc;
 }
 
-RC Table::rollback_delete(Trx *trx, const RID &rid) {
-  RC rc = RC::SUCCESS;
-  Record record;
-  rc = record_handler_->get_record(&rid, &record);
-  if (rc != RC::SUCCESS) {
-    return rc;
-  }
+RC Table::rollback_delete(Trx* trx, const RID& rid) {
+    RC rc = RC::SUCCESS;
+    Record record;
+    rc = record_handler_->get_record(&rid, &record);
+    if (rc != RC::SUCCESS) {
+        return rc;
+    }
 
-  return trx->rollback_delete(this, record); // update record in place
+    return trx->rollback_delete(this, record); // update record in place
 }
 
-RC Table::insert_entry_of_indexes(const char *record, const RID &rid) {
-  RC rc = RC::SUCCESS;
-  for (Index *index : indexes_) {
-    rc = index->insert_entry(record, &rid);
-    if (rc != RC::SUCCESS) {
-      break;
+RC Table::insert_entry_of_indexes(const char* record, const RID& rid) {
+    RC rc = RC::SUCCESS;
+    for (Index* index : indexes_) {
+        rc = index->insert_entry(record, &rid);
+        if (rc != RC::SUCCESS) {
+            break;
+        }
     }
-  }
-  return rc;
+    return rc;
 }
 
-RC Table::delete_entry_of_indexes(const char *record, const RID &rid, bool error_on_not_exists) {
-  RC rc = RC::SUCCESS;
-  for (Index *index : indexes_) {
-    rc = index->delete_entry(record, &rid);
-    if (rc != RC::SUCCESS) {
-      if (rc != RC::RECORD_INVALID_KEY || !error_on_not_exists) {
-        break;
-      }
+RC Table::delete_entry_of_indexes(const char* record, const RID& rid, bool error_on_not_exists) {
+    RC rc = RC::SUCCESS;
+    for (Index* index : indexes_) {
+        rc = index->delete_entry(record, &rid);
+        if (rc != RC::SUCCESS) {
+            if (rc != RC::RECORD_INVALID_KEY || !error_on_not_exists) {
+                break;
+            }
+        }
     }
-  }
-  return rc;
+    return rc;
 }
 
-Index *Table::find_index(const char *index_name) const {
-  for (Index *index: indexes_) {
-    if (0 == strcmp(index->index_meta().name(), index_name)) {
-      return index;
+Index* Table::find_index(const char* index_name) const {
+    for (Index* index : indexes_) {
+        if (0 == strcmp(index->index_meta().name(), index_name)) {
+            return index;
+        }
     }
-  }
-  return nullptr;
-}
-
-IndexScanner *Table::find_index_for_scan(const DefaultConditionFilter &filter) {
-  const ConDesc *field_cond_desc = nullptr;
-  const ConDesc *value_cond_desc = nullptr;
-  if (filter.left().is_attr && !filter.right().is_attr) {
-    field_cond_desc = &filter.left();
-    value_cond_desc = &filter.right();
-  } else if (filter.right().is_attr && !filter.left().is_attr) {
-    field_cond_desc = &filter.right();
-    value_cond_desc = &filter.left();
-  }
-  if (field_cond_desc == nullptr || value_cond_desc == nullptr) {
     return nullptr;
-  }
+}
 
-  const FieldMeta *field_meta = table_meta_.find_field_by_offset(field_cond_desc->attr_offset);
-  if (nullptr == field_meta) {
-    LOG_PANIC("Cannot find field by offset %d. table=%s",
-              field_cond_desc->attr_offset, name());
-    return nullptr;
-  }
+IndexScanner* Table::find_index_for_scan(const DefaultConditionFilter& filter) {
+    const ConDesc* field_cond_desc = nullptr;
+    const ConDesc* value_cond_desc = nullptr;
+    if (filter.left().is_attr && !filter.right().is_attr) {
+        field_cond_desc = &filter.left();
+        value_cond_desc = &filter.right();
+    }
+    else if (filter.right().is_attr && !filter.left().is_attr) {
+        field_cond_desc = &filter.right();
+        value_cond_desc = &filter.left();
+    }
+    if (field_cond_desc == nullptr || value_cond_desc == nullptr) {
+        return nullptr;
+    }
 
-  const IndexMeta *index_meta = table_meta_.find_index_by_field(field_meta->name());
-  if (nullptr == index_meta) {
-    return nullptr;
-  }
+    const FieldMeta* field_meta = table_meta_.find_field_by_offset(field_cond_desc->attr_offset);
+    if (nullptr == field_meta) {
+        LOG_PANIC("Cannot find field by offset %d. table=%s",
+            field_cond_desc->attr_offset, name());
+        return nullptr;
+    }
 
-  Index *index = find_index(index_meta->name());
-  if (nullptr == index) {
-    return nullptr;
-  }
+    const IndexMeta* index_meta = table_meta_.find_index_by_field(field_meta->name());
+    if (nullptr == index_meta) {
+        return nullptr;
+    }
+
+    Index* index = find_index(index_meta->name());
+    if (nullptr == index) {
+        return nullptr;
+    }
 
-  return index->create_scanner(filter.comp_op(), (const char *)value_cond_desc->value);
+    return index->create_scanner(filter.comp_op(), (const char*)value_cond_desc->value);
 }
 
-IndexScanner *Table::find_index_for_scan(const ConditionFilter *filter) {
-  if (nullptr == filter) {
-    return nullptr;
-  }
+IndexScanner* Table::find_index_for_scan(const ConditionFilter* filter) {
+    if (nullptr == filter) {
+        return nullptr;
+    }
 
-  // remove dynamic_cast
-  const DefaultConditionFilter *default_condition_filter = dynamic_cast<const DefaultConditionFilter *>(filter);
-  if (default_condition_filter != nullptr) {
-    return find_index_for_scan(*default_condition_filter);
-  }
+    // remove dynamic_cast
+    const DefaultConditionFilter* default_condition_filter = dynamic_cast<const DefaultConditionFilter*>(filter);
+    if (default_condition_filter != nullptr) {
+        return find_index_for_scan(*default_condition_filter);
+    }
 
-  const CompositeConditionFilter *composite_condition_filter = dynamic_cast<const CompositeConditionFilter *>(filter);
-  if (composite_condition_filter != nullptr) {
-    int filter_num = composite_condition_filter->filter_num();
-    for (int i = 0; i < filter_num; i++) {
-      IndexScanner *scanner= find_index_for_scan(&composite_condition_filter->filter(i));
-      if (scanner != nullptr) {
-        return scanner; // 可以找到一个最优的，比如比较符号是=
-      }
+    const CompositeConditionFilter* composite_condition_filter = dynamic_cast<const CompositeConditionFilter*>(filter);
+    if (composite_condition_filter != nullptr) {
+        int filter_num = composite_condition_filter->filter_num();
+        for (int i = 0; i < filter_num; i++) {
+            IndexScanner* scanner = find_index_for_scan(&composite_condition_filter->filter(i));
+            if (scanner != nullptr) {
+                return scanner; // 可以找到一个最优的，比如比较符号是=
+            }
+        }
     }
-  }
-  return nullptr;
+    return nullptr;
 }
 
 RC Table::sync() {
-  RC rc = data_buffer_pool_->flush_all_pages(file_id_);
-  if (rc != RC::SUCCESS) {
-    LOG_ERROR("Failed to flush table's data pages. table=%s, rc=%d:%s", name(), rc, strrc(rc));
-    return rc;
-  }
-
-  for (Index *index: indexes_) {
-    rc = index->sync();
+    RC rc = data_buffer_pool_->flush_all_pages(file_id_);
     if (rc != RC::SUCCESS) {
-      LOG_ERROR("Failed to flush index's pages. table=%s, index=%s, rc=%d:%s",
+        LOG_ERROR("Failed to flush table's data pages. table=%s, rc=%d:%s", name(), rc, strrc(rc));
+        return rc;
+    }
+
+    for (Index* index : indexes_) {
+        rc = index->sync();
+        if (rc != RC::SUCCESS) {
+            LOG_ERROR("Failed to flush index's pages. table=%s, index=%s, rc=%d:%s",
                 name(), index->index_meta().name(), rc, strrc(rc));
-      return rc;
+            return rc;
+        }
     }
-  }
-  LOG_INFO("Sync table over. table=%s", name());
-  return rc;
-}
+    LOG_INFO("Sync table over. table=%s", name());
+    return rc;
+}
\ No newline at end of file
diff --git a/src/observer/storage/common/table.h b/src/observer/storage/common/table.h
index ab060cf..8ad19fb 100644
--- a/src/observer/storage/common/table.h
+++ b/src/observer/storage/common/table.h
@@ -58,8 +58,6 @@ public:
   RC scan_record(Trx *trx, ConditionFilter *filter, int limit, std::vector<RID >& ridlist);
   RC create_index(Trx *trx, const char *index_name, const char *attribute_name);
 
-  bool check_date(const Value value);
-
 public:
   const char *name() const;
 
@@ -96,6 +94,9 @@ private:
 private:
   Index *find_index(const char *index_name) const;
 
+  //add for update 
+  RC update_index(Trx* trx, const char* attribute_name);
+
 private:
   std::string             base_dir_;
   TableMeta               table_meta_;
diff --git a/src/observer/storage/default/default_handler.cpp b/src/observer/storage/default/default_handler.cpp
index 34a6417..eb0f165 100644
--- a/src/observer/storage/default/default_handler.cpp
+++ b/src/observer/storage/default/default_handler.cpp
@@ -128,7 +128,61 @@ RC DefaultHandler::create_table(const char *dbname, const char *relation_name, i
 }
 
 RC DefaultHandler::drop_table(const char *dbname, const char *relation_name) {
-  return RC::GENERIC_ERROR;
+  //by xiayuan:
+  Db* db = find_db(dbname);
+  if (db == nullptr) {
+      return RC::SCHEMA_DB_NOT_OPENED;
+  }
+  Table* table = find_table(dbname, relation_name);
+  if (nullptr == table) {
+      return RC::SCHEMA_TABLE_NOT_EXIST;
+  }
+  //浏览所有index，并删除
+  TableMeta tablemeta = table->table_meta();
+  for (int i = 0; i < tablemeta.index_num(); i++) {
+      const IndexMeta* index_meta = tablemeta.index(i);
+      std::string index_name = index_meta->name();
+      if (drop_index(nullptr, dbname, relation_name, index_name.c_str()) != RC::SUCCESS) {
+          LOG_ERROR("Failed to delete index: %s\n", index_name.c_str());
+          return RC::GENERIC_ERROR;
+      }
+  }
+  std::string relation_name_str = relation_name;
+  //std::string data_file = base_dir_ + relation_name_str + ".data";   不对，干脆不改了
+  //std::string table_file = base_dir_ + relation_name_str + ".table";
+  std::string data_file = "./miniob/db/sys/" + relation_name_str + ".data";
+  std::string table_file = "./miniob/db/sys/" + relation_name_str + ".table";
+  if (remove(data_file.c_str()) != 0) {
+      LOG_ERROR("Failed to delete .data file: %s\n", data_file.c_str());
+      return RC::GENERIC_ERROR;
+  }
+  if (remove(table_file.c_str()) != 0) {
+      LOG_ERROR("Failed to delete .table file: %s\n", table_file.c_str());
+      return RC::GENERIC_ERROR;
+  }
+  delete table;
+  /* a test
+  std::fstream f1,f2;
+  f1.open(data_file.c_str());
+  f2.open(table_file.c_str());
+  if (f1.is_open()) {
+      f1.close();
+      LOG_INFO("Failed to delete .data file: %s\n", data_file.c_str());
+      return RC::GENERIC_ERROR;
+  }
+  if (f2.is_open()) {
+      f2.close();
+      LOG_INFO("Failed to delete .data file: %s\n", table_file.c_str());
+      return RC::GENERIC_ERROR;
+  }
+  */
+  if (db->open_all_tables() != RC::SUCCESS) {
+      LOG_INFO("Failed to flush opened_tables_\n");
+      return RC::GENERIC_ERROR;
+  }
+
+  ///
+  return RC::SUCCESS;
 }
 
 RC DefaultHandler::create_index(Trx *trx, const char *dbname, const char *relation_name, const char *index_name, const char *attribute_name) {
@@ -140,8 +194,28 @@ RC DefaultHandler::create_index(Trx *trx, const char *dbname, const char *relati
 }
 
 RC DefaultHandler::drop_index(Trx *trx, const char *dbname, const char *relation_name, const char *index_name) {
+  //by xiayuan: drop index
+    Table* table = find_table(dbname, relation_name);
+    if (nullptr == table) {  //table不存在
+        return RC::SCHEMA_TABLE_NOT_EXIST;
+    }
+    TableMeta tablemeta = table->table_meta();
+    if (tablemeta.index(index_name) == nullptr) {  //index不存在
+        return RC::SCHEMA_INDEX_NOT_EXIST;
+    }
 
-  return RC::GENERIC_ERROR;
+    std::string relation_name_str = relation_name;
+    std::string indexfile_name = relation_name_str + "-";
+    indexfile_name += index_name;
+    indexfile_name += ".index";
+    //std::string index_path = base_dir_ + indexfile_name;
+    std::string index_path = "./miniob/db/sys/" + indexfile_name;
+    if (remove(index_path.c_str()) != 0) {  //删除失败
+        LOG_ERROR("Failed to delete .index file: %s\n", index_path.c_str());
+        return RC::GENERIC_ERROR;
+    }
+
+  return RC::SUCCESS;
 }
 
 RC DefaultHandler::insert_record(Trx *trx, const char *dbname, const char *relation_name, int value_num, const Value *values) {
diff --git a/src/observer/storage/default/default_storage_stage.cpp b/src/observer/storage/default/default_storage_stage.cpp
index bb9cc4e..fb28dee 100644
--- a/src/observer/storage/default/default_storage_stage.cpp
+++ b/src/observer/storage/default/default_storage_stage.cpp
@@ -161,6 +161,16 @@ void DefaultStorageStage::handle_event(StageEvent *event) {
   char response[256];
   switch (sql->flag)
   {
+  ////////
+  case SCF_DROP_TABLE: { //by xiayuan: drop table
+      const DropTable& droptable = sql->sstr.drop_table;
+      const char* table_name = droptable.relation_name;
+      rc = handler_->drop_table(current_db, table_name);
+      snprintf(response, sizeof(response), "%s\n", rc == RC::SUCCESS ? "SUCCESS" : "FAILURE");
+    }
+    break;
+  ///////              
+
   case SCF_INSERT: { // insert into
       const Inserts &inserts = sql->sstr.insertion;
       const char *table_name = inserts.relation_name;
@@ -335,21 +345,6 @@ RC insert_record_from_file(Table *table, std::vector<std::string> &file_values,
         value_init_string(&record_values[i], file_value.c_str());
       }
       break;
-      case DATES:{
-        deserialize_stream.clear(); // 清理stream的状态，防止多次解析出现异常
-        deserialize_stream.str(file_value);
-
-        char date_value[15];
-        deserialize_stream >> date_value;
-        if (!deserialize_stream || !deserialize_stream.eof()) {
-          errmsg << "need an date but got '" << file_values[i] 
-                 << "' (field index:" << i << ")";
-
-          rc = RC::SCHEMA_FIELD_TYPE_MISMATCH;
-        } else {
-          value_init_date(&record_values[i], date_value);
-        }
-      }break;
       default: {
         errmsg << "Unsupported field type to loading: " << field->type();
         rc = RC::SCHEMA_FIELD_TYPE_MISMATCH;
